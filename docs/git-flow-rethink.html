<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <link rel="shortcut icon" href="/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <link rel="icon" type="image/x-icon" href="assets/img/favicon.ico" />
        <title>Mark Hazleton - Git Flow Rethink</title>
        <meta name="description" content="Mark Hazleton - Git Flow Rethink" />
        <meta name="author" content="Mark Hazleton" />
        <link rel="canonical" href="https://markhazleton.controlorigins.com/git-flow-rethink.html" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v6.3.0/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link rel="stylesheet" href="css/styles.css?version=1690731123841" />
        <link href="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/devicon.min.css" rel="stylesheet" type="text/css" />
        <!-- Global site tag (gtag.js) - Google Analytics-->
        <script src="https://www.googletagmanager.com/gtag/js?id=G-L8GVZNDH0B" async></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() {
                dataLayer.push(arguments);
            }
            gtag('js', new Date());
            gtag('config', 'G-L8GVZNDH0B');
        </script>
        <script>
            (function (c, l, a, r, i, t, y) {
                c[a] =
                    c[a] ||
                    function () {
                        (c[a].q = c[a].q || []).push(arguments);
                    };
                t = l.createElement(r);
                t.async = 1;
                t.src = 'https://www.clarity.ms/tag/' + i + '?ref=bwt';
                y = l.getElementsByTagName(r)[0];
                y.parentNode.insertBefore(t, y);
            })(window, document, 'clarity', 'script', 'd628hovv63');
        </script>
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
            <a class="navbar-brand js-scroll-trigger" href="/#page-top" title="Mark Hazleton">
                <span class="d-block d-lg-none">Mark Hazleton</span>
                <span class="d-none d-lg-block"><img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="assets/img/MarkHazleton.jpg" alt="..." /></span>
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarResponsive">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="/#about">About</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="/#skills">Skills</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="/#projects">Projects</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="/#experience">Experience</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="/#education">Education</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="/#interests">Interests</a></li>
                </ul>
            </div>
        </nav>
        <!-- Page Content-->
        <div class="container-fluid p-0">
            <section class="painteddesert-section painteddesert-section-background" id="post">
                <div class="painteddesert-section-content">
                    <h1 class="mb-0">Git Flow Rethink</h1>
                    <div class="subheading mb-3">Revaluating the meaning of Continuous in CI/CD</div>
                    <h2 class="mb-3">Git Flow Experience</h2>
                    <p>As developers, we've spent years honing our craft and embracing the Git Flow branching methodology. It's served us well, providing structure and clarity in our version control and collaboration efforts. But here's the rub: the world of software development and DevOps is evolving faster than ever. How can we keep up with these changes? Rather than throwing the baby out with the bathwater and starting from scratch, what if we could take what we've learned from years of Git Flow and evolve it to harness the power of the current DevOps tools at our disposal?</p>
                    <p>Let us embark on a journey of continuous improvement, seeking to enhance our processes without abandoning the foundation we've built. We'll explore how the landscape of software development has transformed and recognize that the primary concerns addressed by Git Flow may not be as prevalent today. There is a way to adapt and evolve our practices to embrace the efficiencies provided by modern DevOps tools.</p>
                    <p>By embracing the concept of continuous integration and deployment, we can simplify our workflows while maintaining the necessary quality assurance measures. It's a balancing act of taking the best of Git Flow and integrating it with the power of modern tooling.</p>
                    <div class="card">
                        <div class="card-header"><h3 class="mb-3">Git Flow Recap</h3></div>
                        <div class="card-body">
                            <p>
                                The Git Flow branching methodology, created by Vincent Driessen and popularized through his blog post titled
                                <a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank">"A successful Git branching model"</a>
                                , has been widely adopted by software development shops as the formal way to manage changes. Its structured approach provided a clear workflow for version control and collaboration. It has served me well as my go-to branching model for many years. But as we embrace the power of continuous integration and deployment, some of the aspects of Git Flow seem to introduce unnecessary ceremony into the development process.
                            </p>
                            <p>In a recent update to the orginal blog post, Vincent Driessen states:</p>
                            <blockquote>If your team is doing continuous delivery of software, I would suggest to adopt a much simpler workflow instead of trying to shoehorn git-flow into your team.</blockquote>
                        </div>
                    </div>
                    <p>After using the model for years, I took a step back and had to ask if git flow the best branching model for my team. Or was I following it becuase it was the way I had always done it? In many projects, I found that I did not need much of the ceremony of Git Flow. On my projects we did not have multiple teams working in the same repository on features that spanned multiple iterations. Web applications that continuously impove, did not need the rigor or being able to quickly restore the product back several versions.</p>
                    <p>After many discussions on the merits of Git Flow, particularly the use of permanent development and main branches and branch creation for each release with a merge back into both develop and main branches has created tasks that seem to add more form than substance. The DevOps tooling does not support the Git Flow branching model out of the box, requiring manual intervention and inforcement via processs and procedures. This manual intervention can lead to inconsistencies.</p>
                    <dl>
                        <dt>Branch Policies and Protection</dt>
                        <dd><p>In the Git Flow branching model, temporary branches such as release and hotfix branches play a crucial role in managing specific features or addressing critical issues. However, implementing branch policies on these temporary branches can pose challenges, particularly in certain DevOps platforms like Azure DevOps. The difficulty arises from the manual application of default and compare branch attributes to each new branch, which can result in release and hotfix branches lacking the same level of protection as permanent branches.</p></dd>
                        <dt>What is in Production?</dt>
                        <dd>
                            <p>One of the challenges with the traditional Git Flow branching model is determining what exactly is in production by simply looking at the repository. In Git Flow, temporary branches are often created for releases and hotfixes, which are subsequently merged back into the develop and main branches. However, in many cases, the release or hotfix branch remains open after deployment, allowing for quick fixes if necessary. This practice can make it difficult to clearly identify the exact state of the production environment by examining the repository alone.</p>
                            <p>The ambiguity surrounding what is in production becomes a concern, particularly when trying to trace back specific changes or identify the codebase associated with a particular release. Without clear indicators or references, developers and team members may find it challenging to pinpoint the exact code deployed in the production environment. This lack of visibility can hinder troubleshooting efforts and make it harder to establish a comprehensive understanding of the software's state.</p>
                        </dd>
                        <dt>False Sense of Security</dt>
                        <dd><p>The Git Flow branching model's reliance on two branches, develop and main, can lead to a false sense of security. In this model, any commit merged into the develop branch eventually makes its way into the main branch and production. However, this means that the develop branch requires the same level of control and scrutiny as the main branch. Unfortunately, the develop branch often becomes a temporary workspace for ongoing development, making it susceptible to inconsistencies and lax code quality controls. Additionally, the lack of branch policies on temporary branches complicates maintaining code integrity throughout the development process.</p></dd>
                    </dl>
                    <h2 class="mb-3">A Single Permanent Branch</h2>
                    <p>In response to the limitations and challenges posed by Git Flow, an alternative approach gaining momentum is the adoption of a single branch strategy. This approach involves using a single branch for all pull requests, streamlining the development process and simplifying the codebase management. But how can this single branch approach overcome the weaknesses of Git Flow and ensure efficient and controlled development?</p>
                    <p>The answer lies in leveraging the power of modern DevOps tooling. The tooling available today provides robust features and automation capabilities that can offset the manual processes and policies traditionally required in Git Flow. Let's explore how these tools can address the weaknesses and enhance the efficiency of the single branch approach.</p>
                    <dl>
                        <dt>Automated branch policies</dt>
                        <dd><p>DevOps platforms such as Azure DevOps, GitHub, and GitLab offer automated branch policies. These policies can be easily configured to enforce code reviews, unit tests, and other quality checks for every pull request. By configuring these policies on your permanent branch, developers can focus on coding while the tooling ensures the necessary quality assurance measures are in place.</p></dd>
                        <dt>Continuous Integration and Deployment (CI/CD) pipelines</dt>
                        <dd><p>Modern CI/CD pipelines provide seamless integration with version control systems. They can be configured to trigger automated builds, tests, and deployments for every pull request and merge into the single branch. This ensures that code changes are continuously integrated, validated, and deployed to development ,staging, and ultimately production environments, enabling rapid feedback loops and early identification of issues.</p></dd>
                        <dt>Versioning</dt>
                        <dd><p>You can configure you project to automactily create versions upon every build. This means you can look at the assemblies and easily know when they were built and what version they are. This is a huge benefit when trying to determine what is in production. With a single branch approach, the tooling can facilitate automated versioning, tagging, and release creation based on specific commits within the single branch. This simplifies the process of identifying what is in production and enables teams to track and manage releases more effectively.</p></dd>
                    </dl>
                    <p>By embracing the single branch approach and utilizing the advanced tooling available, we can optimize our development processes and mitigate the weaknesses associated with Git Flow. The automated branch policies, CI/CD pipelines, and release management features empower teams to enforce quality controls, ensure continuous integration and deployment, and streamline the identification of code in production.</p>
                    <p>The reliance on manual processes and policies in Git Flow can be significantly reduced. This enables developers to focus on delivering value more rapidly without sacrificing code quality. By leveraging the advancements in DevOps tooling, the single branch approach becomes a powerful strategy for efficient and controlled software development, ultimately leading to improved productivity and software delivery.</p>
                    <p>This rethink of the Git Flow branching model opens up new possibilities for teams to innovate, collaborate, and accelerate their development processes. It liberates developers from unnecessary complexities and allows them to concentrate on what truly matters—building great software.</p>
                </div>
            </section>
        </div>
    </body>
</html>
<footer class="navbar-dark bg-primary">
    <div class="row">
        <div class="col-1"><br /></div>
        <div class="col-8">
            <br />
            <script src="https://utteranc.es/client.js" repo="markhazleton/markhazleton-resume" issue-term="title" theme="github-dark-orange" crossorigin="anonymous" async=""></script>
            <br />
        </div>
        <div class="col-3">
            <br />
            <div class="social-icons">
                <a class="social-icon" href="https://www.linkedin.com/in/markhazleton" target="_blank" rel="noopener noreferrer" title="LinkedIn Profile"><i class="fab fa-linkedin-in"></i></a>
                <a class="social-icon" href="https://github.com/markhazleton" target="_blank" rel="noopener noreferrer" title="GitHub Profile"><i class="fab fa-github"></i></a>
                <a class="social-icon" href="https://www.youtube.com/@MarkHazleton" target="_blank" rel="noopener noreferrer" title="YouTube Channel"><i class="fab fa-youtube"></i></a>
                <a class="social-icon" href="https://www.instagram.com/markhazleton/" target="_blank" rel="noopener noreferrer" title="Instagram Profile"><i class="fab fa-instagram"></i></a>
                <br />
            </div>
        </div>
    </div>
</footer>
<!-- Bootstrap core JS-->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<!-- Core theme JS-->
<script src="js/scripts.js"></script>

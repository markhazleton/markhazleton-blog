extends layouts/modern-layout

block variables
  - var pageTitle = 'Master Concurrent Async Tasks with TaskListProcessor'
  - var pageDescription = 'Learn to manage multiple async tasks in .NET with TaskListProcessor. Dive into error handling, telemetry, and scalability for robust applications.'
  - var pageKeywords = 'TaskListProcessor, .NET concurrency, async tasks, error handling, task telemetry, application scalability, .NET async patterns, C# task management'
  - var pageCanonical = 'https://markhazleton.com/task-list-processor.html'

block pagehead
  title= pageTitle + ' | Mark Hazleton'
  meta(name='description', content=pageDescription)
  meta(name='keywords', content=pageKeywords)
  meta(name='author', content='Mark Hazleton')

block og_overrides
  meta(property='og:title', content=pageTitle)
  meta(property='og:description', content='Step up your .NET game by mastering concurrent async tasks using TaskListProcessor. Perfect for building scalable and robust .NET applications.')
  meta(property='og:url', content=pageCanonical)
  meta(property='og:type', content='article')
  meta(property='og:image', content='https://markhazleton.com/assets/img/Task-List-Processor-Dashboard.png')

block twitter_overrides
  meta(name='twitter:card', content='summary_large_image')
  meta(name='twitter:title', content=pageTitle)
  meta(name='twitter:description', content='Exclusive insights into managing async tasks in .NET with efficiency. Learn about TaskListProcessor\'s advanced error handling and performance tracking.')
  meta(name='twitter:image', content='https://markhazleton.com/assets/img/Task-List-Processor-Dashboard.png')

block canonical
  link(rel='canonical', href=pageCanonical)

block layout-content
  // Hero Section
  section.bg-gradient-primary.py-5
    .container
      .row.align-items-center
        .col-lg-10.mx-auto.text-center
          h1.display-4.fw-bold.mb-3
            i.bi.bi-list-task.me-3
            | TaskListProcessor
          h2.h3.mb-4 Mastering Concurrent Operations in .NET
          p.lead.mb-5 Handle multiple asynchronous operations with grace and precision. Build scalable and maintainable .NET applications with advanced error handling and telemetry.

  // Main Article
  article#main-article
    .container
      .row
        .col-lg-8.mx-auto
          header.mb-5
            .article-meta.text-muted.mb-4
              time(datetime='2025-05-30') May 30, 2025
              span.mx-2 â€¢
              span 15 min read

            .alert.alert-primary.mb-4
              h5.alert-heading
                i.bi.bi-github.me-2
                | Source Code Available
              p.mb-0
                | The source code for
                a.text-decoration-none(href='https://github.com/markhazleton/TaskListProcessor' target='_blank' rel='noopener noreferrer') TaskListProcessor is available on GitHub
                | . Clone the repository to follow along with the examples.

          .article-content
            p.lead.
              In application development, efficiency is not just a goal; it's a necessity.
              As .NET developers, we often encounter scenarios where we must juggle multiple operations simultaneously.
              The TaskListProcessor class addresses these issues with efficiency, handling multiple asynchronous operations with grace and precision.

            // Table of Contents
            nav.mb-5(aria-label='Table of Contents')
              .card
                .card-header.bg-primary.text-white
                  h3.card-title.mb-0
                    i.bi.bi-list-ul.me-2
                    | Contents
                .card-body
                  ol.list-group.list-group-numbered.list-group-flush
                    li.list-group-item
                      a.text-decoration-none(href='#challenges') Development Challenges
                    li.list-group-item
                      a.text-decoration-none(href='#comparison') Task.WhenAll vs Parallel Methods
                    li.list-group-item
                      a.text-decoration-none(href='#use-case') Travel Website Use Case
                    li.list-group-item
                      a.text-decoration-none(href='#technical-terms') Technical Jargon Explained
                    li.list-group-item
                      a.text-decoration-none(href='#whenall-method') WhenAllWithLoggingAsync Method
                    li.list-group-item
                      a.text-decoration-none(href='#gettask-method') GetTaskResultAsync Method
                    li.list-group-item
                      a.text-decoration-none(href='#taskresult-class') TaskResult Class
                    li.list-group-item
                      a.text-decoration-none(href='#weather-service') WeatherService Implementation
                    li.list-group-item
                      a.text-decoration-none(href='#dashboard-demo') Travel Dashboard Demo
                    li.list-group-item
                      a.text-decoration-none(href='#conclusion') Test Drive & Conclusion

            // Development Challenges Section
            section#challenges.mb-5
              .card.border-0.shadow-sm
                .card-header.bg-warning.text-dark
                  h2.card-title.mb-0
                    i.bi.bi-exclamation-triangle.me-2
                    | Development Challenges
                .card-body
                  p.
                    The TaskListProcessor addresses common challenges in .NET concurrent programming,
                    providing a structured approach to running concurrent tasks with different return types.

                  .row.g-4
                    .col-md-6
                      .card.h-100.border-danger
                        .card-header.bg-danger.text-white
                          h5.mb-0
                            i.bi.bi-code-slash.me-2
                            | Issue: Diverse Return Types
                        .card-body
                          p.card-text.
                            A common issue with concurrent async methods in .NET is handling different return types.
                            Traditional approaches often lead to tangled code, where task management becomes cumbersome and error-prone.

                    .col-md-6
                      .card.h-100.border-warning
                        .card-header.bg-warning.text-dark
                          h5.mb-0
                            i.bi.bi-exclamation-circle.me-2
                            | Issue: Error Propagation
                        .card-body
                          p.card-text.
                            Without proper structure, errors from individual tasks can propagate and cause widespread failures.
                            This necessitates a robust mechanism to encapsulate errors and handle them gracefully.

                    .col-md-6
                      .card.h-100.border-success
                        .card-header.bg-success.text-white
                          h5.mb-0
                            i.bi.bi-check-circle.me-2
                            | Solution: TaskListProcessor
                        .card-body
                          p.card-text.
                            The TaskListProcessor class addresses these issues head-on, providing a cohesive way to manage
                            a list of tasks regardless of their return types, with built-in error handling and logging.

                    .col-md-6
                      .card.h-100.border-info
                        .card-header.bg-info.text-white
                          h5.mb-0
                            i.bi.bi-speedometer2.me-2
                            | Benefit: Enhanced Performance
                        .card-body
                          p.card-text.
                            Features methods like WhenAllWithLoggingAsync, which enhance the standard Task.WhenAll
                            with error oversight, flexibility, and scalability using generics and TaskResult objects.

            // Comparison Section
            section#comparison.mb-5
              .card.border-0.shadow-sm
                .card-header.bg-info.text-white
                  h2.card-title.mb-0
                    i.bi.bi-arrow-left-right.me-2
                    | Task.WhenAll vs. Parallel Methods
                .card-body
                  .row.align-items-center.mb-4
                    .col-md-4
                      img.img-fluid.rounded(
                        src='assets/img/Task-List-Processor-WhenAll-vs-Parallel.png'
                        alt='Task.WhenAll vs Parallel.ForEach comparison'
                        title='Task.WhenAll vs Parallel.ForEach. Image Credit ChatGPT with DALL-E'
                        loading='lazy'
                      )
                    .col-md-8
                      p.lead.
                        The choice between using Task.WhenAll and Parallel methods can be effectively illustrated through the metaphor of
                        runners on a track and a tug-of-war contest.
                      p.
                        Understanding these differences will help us appreciate the benefits of the TaskListProcessor
                        and select the right approach for your concurrent processing needs.

                  .row.g-4
                    .col-md-6
                      .card.h-100.border-success
                        .card-header.bg-success.text-white
                          h5.mb-0
                            i.bi.bi-person-walking.me-2
                            | Task.WhenAll as Runners
                        .card-body
                          p.card-text.
                            Imagine runners, each in their own lane on a track. This represents Task.WhenAll for handling
                            asynchronous, I/O-bound tasks. Each task runs independently without blocking others,
                            ensuring efficiency for network requests or file I/O operations.

                    .col-md-6
                      .card.h-100.border-warning
                        .card-header.bg-warning.text-dark
                          h5.mb-0
                            i.bi.bi-people.me-2
                            | Parallel Methods as Tug-of-War
                        .card-body
                          p.card-text.
                            A tug-of-war contest represents Parallel methods for CPU-bound tasks. Teams work together
                            with synchronized effort, similar to how parallel processing distributes computational
                            weight across multiple threads for maximum CPU utilization.

            // Use Case Section
            section#use-case.mb-5
              .card.border-0.shadow-sm
                .card-header.bg-primary.text-white
                  h2.card-title.mb-0
                    i.bi.bi-map.me-2
                    | Use Case: Travel Website Dashboard
                .card-body
                  .row.align-items-center.mb-4
                    .col-md-3
                      img.img-fluid.rounded(
                        src='assets/img/Task-List-Processor-Use-Case.png'
                        alt='Task List Processor Use Case for travel website'
                        title='Task List Processor Use Case. Image Credit ChatGPT with DALL-E'
                        loading='lazy'
                      )
                    .col-md-9
                      p.
                        Consider a travel website displaying a dashboard of top destination cities,
                        aggregating data like weather, attractions, events, and flights from multiple sources.

                  .row.g-4
                    .col-md-4
                      .card.h-100.border-danger
                        .card-header.bg-danger.text-white
                          h5.mb-0
                            i.bi.bi-exclamation-triangle.me-2
                            | Performance Challenges
                        .card-body
                          ul.list-unstyled
                            li.mb-2
                              i.bi.bi-clock.text-danger.me-2
                              | Diverse data sources with different response times
                            li.mb-0
                              i.bi.bi-gear.text-danger.me-2
                              | Inconsistent data retrieval complexity

                    .col-md-4
                      .card.h-100.border-success
                        .card-header.bg-success.text-white
                          h5.mb-0
                            i.bi.bi-check-circle.me-2
                            | TaskListProcessor Solution
                        .card-body
                          ul.list-unstyled
                            li.mb-2
                              i.bi.bi-speedometer2.text-success.me-2
                              | Concurrent data retrieval for faster loading
                            li.mb-0
                              i.bi.bi-shield-check.text-success.me-2
                              | Robust error handling prevents cascade failures

                    .col-md-4
                      .card.h-100.border-info
                        .card-header.bg-info.text-white
                          h5.mb-0
                            i.bi.bi-graph-up.me-2
                            | Business Benefits
                        .card-body
                          ul.list-unstyled
                            li.mb-2
                              i.bi.bi-display.text-info.me-2
                              | Responsive dashboard with partial data display
                            li.mb-0
                              i.bi.bi-heart.text-info.me-2
                              | Maintains user engagement and trust

            // Technical Terms Section
            section#technical-terms.mb-5
              .card.border-0.shadow-sm
                .card-header.bg-secondary.text-white
                  h2.card-title.mb-0
                    i.bi.bi-book.me-2
                    | Technical Jargon Explained
                .card-body
                  p.
                    Understanding these technical concepts will help you grasp how TaskListProcessor enhances
                    concurrent task management in .NET applications.

                  .row.g-4
                    .col-md-6
                      .card.border-light
                        .card-body
                          h5.card-title
                            i.bi.bi-cpu.text-primary.me-2
                            | Concurrent Asynchronous Tasks
                          p.card-text.
                            Tasks executed simultaneously, each operating independently and completing at its own pace.
                            Essential in multi-threading environments for optimal performance.

                    .col-md-6
                      .card.border-light
                        .card-body
                          h5.card-title
                            i.bi.bi-exclamation-diamond.text-warning.me-2
                            | Error Propagation
                          p.card-text.
                            The process where errors spread from one system part to others, potentially causing
                            wider failures. Effective error handling prevents this cascade effect.

                    .col-md-6
                      .card.border-light
                        .card-body
                          h5.card-title
                            i.bi.bi-graph-up-arrow.text-success.me-2
                            | Telemetry
                          p.card-text.
                            Collection and analysis of system performance data, including metrics like
                            task execution time and error rates for monitoring and optimization.

                    .col-md-6
                      .card.border-light
                        .card-body
                          h5.card-title
                            i.bi.bi-journal-text.text-info.me-2
                            | ILogger & TaskResult
                          p.card-text.
                            ILogger: .NET interface for logging events. TaskResult: Custom object encapsulating
                            task outcomes, storing results, names, and error details.

            // WhenAllWithLoggingAsync Method Section
            section#whenall-method.mb-5
              .card.border-0.shadow-sm
                .card-header.bg-dark.text-white
                  h2.card-title.mb-0
                    i.bi.bi-code-slash.me-2
                    | The WhenAllWithLoggingAsync Method
                .card-body
                  p.
                    The WhenAllWithLoggingAsync method enhances the standard Task.WhenAll with robust error handling
                    and centralized logging capabilities.

                  pre.language-csharp.mb-4
                    code.language-csharp.
                      public static async Task WhenAllWithLoggingAsync(IEnumerable&lt;Task&gt; tasks, ILogger logger)
                      {
                        ArgumentNullException.ThrowIfNull(logger);
                        try
                        {
                          await Task.WhenAll(tasks);
                        }
                        catch (Exception ex)
                        {
                          logger.LogError(ex, "TLP: An error occurred while executing one or more tasks.");
                        }
                      }

                  .row.g-4
                    .col-md-6
                      .card.border-success
                        .card-header.bg-success.text-white
                          h6.mb-0
                            i.bi.bi-shield-check.me-2
                            | Enhanced Error Handling
                        .card-body
                          p.card-text.small.
                            Instead of allowing exceptions to propagate and potentially crash the application,
                            it catches exceptions and logs them for debugging and analysis.

                    .col-md-6
                      .card.border-info
                        .card-header.bg-info.text-white
                          h6.mb-0
                            i.bi.bi-journal-text.me-2
                            | Consolidated Logging
                        .card-body
                          p.card-text.small.
                            Centralized logging of task exceptions with consistent formatting,
                            essential for integrating with logging solutions and services.

                    .col-md-6
                      .card.border-warning
                        .card-header.bg-warning.text-dark
                          h6.mb-0
                            i.bi.bi-play-circle.me-2
                            | Non-Blocking Operation
                        .card-body
                          p.card-text.small.
                            Logs errors internally and allows program continuation,
                            beneficial for non-critical tasks that shouldn't block overall process.

                    .col-md-6
                      .card.border-primary
                        .card-header.bg-primary.text-white
                          h6.mb-0
                            i.bi.bi-gear.me-2
                            | Improved Maintenance
                        .card-body
                          p.card-text.small.
                            Detailed error information aids in faster debugging and simplifies maintenance
                            in complex systems with many concurrent tasks.

            // GetTaskResultAsync Method Section
            section#gettask-method.mb-5
              .card.border-0.shadow-sm
                .card-header.bg-primary.text-white
                  h2.card-title.mb-0
                    i.bi.bi-stopwatch.me-2
                    | The GetTaskResultAsync Method
                .card-body
                  p.
                    The GetTaskResultAsync method wraps async calls with telemetry features,
                    measuring execution time and providing performance metrics.

                  pre.language-csharp.mb-4
                    code.language-csharp.
                      public async Task GetTaskResultAsync&lt;T&gt;(string taskName, Task&lt;T&gt; task) where T : class
                      {
                        var sw = new Stopwatch();
                        sw.Start();
                        var taskResult = new TaskResult { Name = taskName };
                        try
                        {
                          taskResult.Data = await task;
                          sw.Stop();
                          Telemetry.Add(GetTelemetry(taskName, sw.ElapsedMilliseconds));
                        }
                        catch (Exception ex)
                        {
                          sw.Stop();
                          Telemetry.Add(GetTelemetry(taskName, sw.ElapsedMilliseconds, "Exception", ex.Message));
                          taskResult.Data = null;
                        }
                        finally
                        {
                          TaskResults.Add(taskResult);
                        }
                      }

                  .row.g-4
                    .col-md-6
                      .card.border-info
                        .card-header.bg-info.text-white
                          h6.mb-0
                            i.bi.bi-clock-history.me-2
                            | Performance Metrics
                        .card-body
                          p.card-text.small.
                            Utilizes Stopwatch to measure and record task execution time,
                            providing valuable performance insights for optimization.

                    .col-md-6
                      .card.border-warning
                        .card-header.bg-warning.text-dark
                          h6.mb-0
                            i.bi.bi-exclamation-triangle.me-2
                            | Error Tracking
                        .card-body
                          p.card-text.small.
                            Captures exceptions during task execution, logging errors with task names
                            and elapsed time for comprehensive analysis.

                    .col-md-6
                      .card.border-success
                        .card-header.bg-success.text-white
                          h6.mb-0
                            i.bi.bi-shield.me-2
                            | Execution Isolation
                        .card-body
                          p.card-text.small.
                            Each task executes in a separate logical block, allowing independent handling
                            where one task failure doesn't impede others.

                    .col-md-6
                      .card.border-primary
                        .card-header.bg-primary.text-white
                          h6.mb-0
                            i.bi.bi-box.me-2
                            | Generic Flexibility
                        .card-body
                          p.card-text.small.
                            Designed to return various object types from different tasks within a single list,
                            enabling heterogeneous task processing.

            // TaskResult Class Section
            section#taskresult-class.mb-5
              .card.border-0.shadow-sm
                .card-header.bg-success.text-white
                  h2.card-title.mb-0
                    i.bi.bi-box-seam.me-2
                    | TaskResult Class Overview
                .card-body
                  p.
                    The TaskResult class is a cornerstone within the TaskListProcessor architecture,
                    designed to encapsulate the outcome of asynchronous tasks with unified structure.

                  pre.language-csharp.mb-4
                    code.language-csharp.
                      public class TaskResult&lt;T&gt; : ITaskResult
                      {
                        public TaskResult()
                        {
                          Name = "UNKNOWN";
                          Data = null;
                        }

                        public TaskResult(string name, T data)
                        {
                          Name = name;
                          Data = data;
                        }
                        public T? Data { get; set; }
                        public string Name { get; set; }
                      }

                  .row.g-4
                    .col-md-6
                      .card.border-primary
                        .card-header.bg-primary.text-white
                          h6.mb-0
                            i.bi.bi-bullseye.me-2
                            | Purpose & Standardization
                        .card-body
                          p.card-text.small.
                            Offers a standardized object representing any task outcome, regardless of nature
                            or return data type, promoting consistency across applications.

                    .col-md-6
                      .card.border-info
                        .card-header.bg-info.text-white
                          h6.mb-0
                            i.bi.bi-arrows-fullscreen.me-2
                            | Generic Flexibility
                        .card-body
                          p.card-text.small.
                            Thanks to generic design, can hold any result data type, making it versatile
                            across projects and scenarios for capturing task execution results.

                    .col-md-6
                      .card.border-warning
                        .card-header.bg-warning.text-dark
                          h6.mb-0
                            i.bi.bi-bug.me-2
                            | Error Handling
                        .card-body
                          p.card-text.small.
                            When tasks fail, stores error details alongside original task information,
                            making it invaluable for error tracking and debugging processes.

                    .col-md-6
                      .card.border-success
                        .card-header.bg-success.text-white
                          h6.mb-0
                            i.bi.bi-graph-up.me-2
                            | Telemetry Integration
                        .card-body
                          p.card-text.small.
                            Can be extended to include telemetry data like execution duration,
                            crucial for performance monitoring and optimization in complex systems.

            // WeatherService Implementation Section
            section#weather-service.mb-5
              .card.border-0.shadow-sm
                .card-header.bg-info.text-white
                  h2.card-title.mb-0
                    i.bi.bi-cloud-sun.me-2
                    | WeatherService Implementation
                .card-body
                  p.
                    The WeatherService class simulates real-world external service calls with artificial latency
                    and potential failures for comprehensive testing scenarios.

                  .row.g-4
                    .col-md-6
                      .card.border-primary
                        .card-header.bg-primary.text-white
                          h6.mb-0
                            i.bi.bi-clock.me-2
                            | Real-World Simulation
                        .card-body
                          p.card-text.small.
                            Mimics external service calls by introducing artificial latency using Random class,
                            simulating network or service delays developers encounter in production.

                    .col-md-6
                      .card.border-danger
                        .card-header.bg-danger.text-white
                          h6.mb-0
                            i.bi.bi-x-circle.me-2
                            | Randomized Error Injection
                        .card-body
                          p.card-text.small.
                            Deliberately throws exceptions based on random conditions to simulate
                            real service failures, ensuring applications handle intermittent failures gracefully.

                    .col-md-6
                      .card.border-warning
                        .card-header.bg-warning.text-dark
                          h6.mb-0
                            i.bi.bi-sliders.me-2
                            | Adjustable Failure Rate
                        .card-body
                          p.card-text.small.
                            Customizable failure likelihood provides flexibility in error introduction frequency,
                            allowing thorough testing under various stress and instability conditions.

                    .col-md-6
                      .card.border-success
                        .card-header.bg-success.text-white
                          h6.mb-0
                            i.bi.bi-check-circle.me-2
                            | Realistic Testing
                        .card-body
                          p.card-text.small.
                            Incorporates randomness in latency and failures for realistic testing environments,
                            ensuring applications handle both success scenarios and unexpected delays.

            // Dashboard Demo Section
            section#dashboard-demo.mb-5
              .card.border-0.shadow-sm
                .card-header.bg-dark.text-white
                  h2.card-title.mb-0
                    i.bi.bi-display.me-2
                    | Travel Dashboard Demo
                .card-body
                  .row.align-items-center.mb-4
                    .col-md-3
                      img.img-fluid.rounded(
                        src='assets/img/Task-List-Processor-Dashboard.png'
                        alt='Task List Processor Dashboard demonstration'
                        title='Task List Processor Dashboard showing concurrent data loading'
                        loading='lazy'
                      )
                    .col-md-9
                      p.
                        Let's examine a practical implementation that demonstrates fetching weather forecasts
                        for multiple cities concurrently, simulating a real-world travel dashboard.

                  .row.g-4.mb-4
                    .col-md-6
                      .card.border-info
                        .card-header.bg-info.text-white
                          h6.mb-0
                            i.bi.bi-speedometer2.me-2
                            | Concurrent Data Retrieval
                        .card-body
                          p.card-text.small.
                            Asynchronous programming makes non-blocking calls to WeatherService for each city,
                            demonstrating parallel data loading for reduced total wait time.

                    .col-md-6
                      .card.border-primary
                        .card-header.bg-primary.text-white
                          h6.mb-0
                            i.bi.bi-terminal.me-2
                            | Console Logging Demo
                        .card-body
                          p.card-text.small.
                            Console.WriteLine outputs progress and results, providing clear sequential logs
                            that mimic how users see data loading on web dashboards.

                  // Code Example
                  pre.language-csharp.mb-4
                    code.language-csharp.
                      var loggerFactory = LoggerFactory.Create(builder => builder.AddConsole());
                      var logger = loggerFactory.CreateLogger&lt;Program&gt;();
                      var weatherService = new WeatherService();
                      var weatherCities = new TaskListProcessing.TaskListProcessor();
                      var cities = new List&lt;string&gt; { "London", "Paris", "New York", "Tokyo", "Sydney", "Chicago", "Dallas", "Wichita" };
                      var tasks = new List&lt;Task&gt;();

                      foreach (var city in cities)
                      {
                        tasks.Add(weatherCities.GetTaskResultAsync(city, weatherService.GetWeather(city)));
                      }

                      await TaskListProcessing.TaskListProcessor.WhenAllWithLoggingAsync(tasks, logger);

                  // Output Example
                  .card.bg-light.mb-4
                    .card-header
                      h6.mb-0
                        i.bi.bi-terminal.me-2
                        | Sample Output
                    .card-body
                      pre.language-json.mb-0
                        code.language-json.
                          Telemetry:
                          Chicago: Task completed in 602 ms with ERROR Exception: Random failure occurred fetching weather data.
                          Paris: Task completed in 723 ms with ERROR Exception: Random failure occurred fetching weather data.
                          Dallas: Task completed in 1,009 ms
                          Sydney: Task completed in 1,318 ms
                          Tokyo: Task completed in 1,921 ms
                          London: Task completed in 2,789 ms

                          Results:
                          Dallas: City: Dallas, Date: 2023-11-10, Temp (F): 40, Summary: Cool
                          Sydney: City: Sydney, Date: 2023-11-10, Temp (F): 116, Summary: Sweltering
                          Tokyo: City: Tokyo, Date: 2023-11-10, Temp (F): 75, Summary: Warm
                          London: City: London, Date: 2023-11-10, Temp (F): 16, Summary: Chilly

            // Updated Implementation Section
            section#updates.mb-5
              .card.border-0.shadow-sm
                .card-header.bg-warning.text-dark
                  h2.card-title.mb-0
                    i.bi.bi-arrow-clockwise.me-2
                    | Enhanced Implementation: CityThingsToDo Service
                .card-body
                  .row.align-items-center.mb-4
                    .col-md-3
                      img.img-fluid.rounded(
                        src='assets/img/Task-List-Processor-Dashboard-Update.png'
                        alt='Updated Task List Processor Dashboard with activities'
                        title='Enhanced dashboard showing both weather and activities'
                        loading='lazy'
                      )
                    .col-md-9
                      p.
                        The latest enhancement introduces the CityThingsToDo service, showcasing the power and flexibility
                        of our architecture to seamlessly integrate different service types and return types.

                  .alert.alert-info.mb-4
                    h6.alert-heading
                      i.bi.bi-lightbulb.me-2
                      | Architecture Benefits
                    p.mb-0.
                      This enhancement demonstrates how TaskListProcessor handles diverse data sources,
                      reflecting real-world scenarios like travel dashboards that provide weather forecasts
                      and activities for different cities with uniform error handling and telemetry.

                  // Enhanced Code Example
                  pre.language-csharp.mb-4
                    code.language-csharp.
                      var thingsToDoService = new CityThingsToDoService();
                      var weatherService = new WeatherService();
                      var cityDashboards = new TaskListProcessorGeneric();
                      var cities = new List&lt;string&gt; { "London", "Paris", "New York", "Tokyo", "Sydney", "Chicago", "Dallas", "Wichita" };
                      var tasks = new List&lt;Task&gt;();

                      foreach (var city in cities)
                      {
                        tasks.Add(cityDashboards.GetTaskResultAsync($"{city} Weather", weatherService.GetWeather(city)));
                        tasks.Add(cityDashboards.GetTaskResultAsync($"{city} Things To Do", thingsToDoService.GetThingsToDoAsync(city)));
                      }

                      await cityDashboards.WhenAllWithLoggingAsync(tasks, logger);

            // Conclusion Section
            section#conclusion.mb-5
              .card.border-0.shadow-sm
                .card-header.bg-success.text-white
                  h2.card-title.mb-0
                    i.bi.bi-rocket-takeoff.me-2
                    | Take TaskListProcessor for a Test Drive
                .card-body
                  p.lead.
                    In the realm of .NET, orchestrating concurrent asynchronous tasks is a common challenge
                    with the potential to become a transformative learning journey.

                  .row.g-4.mb-4
                    .col-md-6
                      .card.h-100.bg-light
                        .card-body.text-center
                          i.bi.bi-github.display-6.text-primary.mb-3
                          h5.card-title Test Drive Experience
                          p.card-text.
                            Clone the repository and experience the power of TaskListProcessor firsthand.
                            A practical step in the lifelong learning journey for .NET developers.
                          a.btn.btn-primary(
                            href='https://github.com/markhazleton/TaskListProcessor'
                            target='_blank'
                            rel='noopener noreferrer'
                          )
                            i.bi.bi-github.me-2
                            | View on GitHub

                    .col-md-6
                      .card.h-100.bg-light
                        .card-body.text-center
                          i.bi.bi-award.display-6.text-success.mb-3
                          h5.card-title Learning Outcomes
                          p.card-text.
                            Master concurrent operations, understand error handling strategies,
                            and implement performance monitoring in your .NET applications.

                  .alert.alert-success
                    h6.alert-heading
                      i.bi.bi-check-circle.me-2
                      | Version Compatibility
                    p.mb-2.
                      TaskListProcessor is developed for .NET 9, offering the latest framework features and optimizations.
                      Regular updates ensure compatibility with new .NET releases and performance enhancements.
                    p.mb-0.
                      Follow our GitHub repository for the latest updates and access to the most current version
                      with ongoing improvements and community contributions.

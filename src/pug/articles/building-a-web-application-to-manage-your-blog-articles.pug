extends ../layouts/articles

block pagehead
  title Development - Building a Web Application to Manage My Blog
  meta(name='description', content='Development - Building a Web Application to Manage Your Blog Articles')
  meta(name='author', content='Mark Hazleton')
  link(rel='canonical', href='https://markhazleton.controlorigins.com/articles/building-a-web-application-to-manage-your-blog-articles.html')

block layout-content

  section#post.painteddesert-section.painteddesert-section-background
    .painteddesert-section-content
      h2 Building a Web Application to Manage My Blog
      strong A Journey into Web Content Management Systems
      p.
        Creating and managing a blog has become an essential part of sharing insights, experiences,
        and expertise with the world.
        For those who want to make it easier to write posts, having a Web Content Management System (CMS)
        to maintain their blog articles just makes sense.
      p.
        This article explores my journey of developing a web application to manage the blog articles on this website.
        The article delves into the process and the parallels with the creation of the Web Project Mechanics (WPM) framework.
      h3.
        The Quest for Better Web Content Management
      p.
        As I add more articles, I increasingly have a desire to manage the articles in a more efficient and customized manner.
        Trying to keep the navigation, sitemap, and article constancy in sync is a tedious task.
        In the past, this has usually led to a journey of building their own CMS.
        So, I embarked on creating a quick application using the tools that I was familiar with.  In this case a Web Application with
        razor pages. I created a bespoke CMS to suit my unique needs on this blog.  The CMS is a web application that allows me to
        manage the articles on this website and keep the sitemap, navigation, and footer links in sync with my new articles.
      p.
        My goal is to create a user-friendly solution to simplify my article management.
      h3.
        From Vision to Reality
      p.
        Building the Blog Management Web Application The journey begins by architecting the web application.
        Drawing from previous experiences in web development, I choose to create a web application that employs
        the Model-View-Controller (MVC) pattern for a structured and organized codebase. With the vision set,
        the next step is to define the internal data structure,
        I wanted to keep the JSON file as my persistence layer for storing article information.
      p.
        The heart of the application lies in the ArticleService, responsible for reading, updating, and adding articles.
        Leveraging the power of C# and ASP.NET Core, the service interacts with JSON files, handling article data with ease.
      p.
        The service is more than just a simple data handler; it becomes the orchestrator of article-related actions,
        from CRUD operations to generating sitemap XML and even dynamically creating article templates.
      h3.
        The Parallels
      p.
        Web Project Mechanics Revisited For those familiar with the
        <a href='/web-project-mechanics.html' target='_blank'>Web Project Mechanics</a>
        (WPM) framework,
        The journey to build a blog management application may seem reminiscent of previous endeavors.
        Just as the WPM framework emerged from the need to streamline project management,
        this CMS venture arose from a passion for efficient content management.
      p.
        Just as WPM offers tools to simplify complex web development tasks,
        the CMS provides tools to streamline article creation, organization, and publication.
        The similarities between these projects highlight the author's affinity for crafting solutions
        that improve workflows and provide tailored experiences.
        Just as the WPM framework brought order to the chaos of web project management,
        this CMS tackles the challenges of blog management, empowering the author to create and share content effortlessly.
        Embracing the Journey As the journey unfolds, the parallels between creating a web application for
        blog management and crafting frameworks like WPM become apparent.
        The allure of transforming ideas into functional tools, refining workflows, and delivering value through technology
        is a driving force that propels developers forward. Just as master craftsman refines their skills over time,
        each project contributes to the developer's repertoire of expertise.
      p.
        The adventure of building a CMS to manage blog articles is not merely a technical feat; it's a
        testament to the fusion of passion for writing and the art of coding.
        With every line of code, the author is not just creating software but crafting a tool that mirrors
        their values and enhance their capabilities.

      h3 Creating an Interface to Manage Articles
      p.
        I have a JSON file that lists all the articles that I have written for this site.   The article JSON file
        is used to create navigation and a sitemap for the site.
        Let's walk through the steps to create an interface that allows me to manage article data stored in a `articles.json` file.
        To get going quickly, I will utilize the power of ChatGPT prompts to generate code snippets along the way.

      dl
        dt Step 1: Create the Article Model and Service
        dd
          p.
            The first step is to create a C# model that represents a project.
            We'll create an `ArticleModel` class to hold article metadata.
          p.
            We can use the ChatGPT prompt to help generate the code for this.

          blockquote.pre.
            Create a model class called ArticleModel in C# for the following JSON file.
            Create a Service to maintain the JSON file which consists of a list of the Article Model class. Here is the JSON for the articles.
            [
              {
                "id": 0,
                "Section": "Personal Philosophy",
                "slug": "sidetrackedbysizzle.html",
                "name": "Sidetracked by Sizzle",
                "content": null,
                "description": "Description for Sidetracked by Sizzle",
                "img_src": "assets/img/ArgostoliGreeceBeach.jpg",
                "lastmod": "2023-09-05",
                "changefreq": "daily"
              },
            }
          p.
            This returns the code for the Article Model.
          pre.code.
            // ArticleModel.cs
            public class ArticleModel
            {
                [JsonPropertyName("id")]
                public int Id { get; set; }

                [JsonPropertyName("Section")]
                public string Section { get; set; }

                [JsonPropertyName("slug")]
                public string Slug { get; set; }

                [JsonPropertyName("name")]
                public string Name { get; set; }

                [JsonPropertyName("content")]
                public string ArticleContent { get; set; }

                [JsonPropertyName("description")]
                public string Description { get; set; }

                [JsonPropertyName("img_src")]
                public string ImgSrc { get; set; }

                [JsonPropertyName("lastmod")]
                public string LastModified { get; set; } = DateTime.Now.ToString("yyyy-MM-dd");

                [JsonPropertyName("changefreq")]
                public string ChangeFrequency { get; set; } = "monthly";
            }
          p.
            And the code for the Article Service.
          pre.code.
            // ArticleService.cs
            public class ArticleService
            {
                private List&lt;ArticleModel&gt; _articles;
                private readonly string _articlesDirectory;
                private readonly string _filePath;

                public List&lt;ArticleModel&gt; GetArticles()
                {
                    using (StreamReader reader = new StreamReader(_jsonFilePath))
                    {
                        string json = reader.ReadToEnd();
                        List&lt;ArticleModel&gt; articles = JsonConvert.DeserializeObject&lt;List&lt;ArticleModel&gt;&gt;(json);
                        return articles;
                    }
              }

              public void SaveArticles(List&lt;ArticleModel&gt; articles)
              {
                string json = JsonConvert.SerializeObject(articles, Formatting.Indented);
                File.WriteAllText(_jsonFilePath, json);
              }
            }

        dt Step 2: Create a Razor Page for Managing Articles
        dd
          p.
            Now let's create a Razor Page to manage the Articles.
            We'll use dependency injection to get the `ArticleService` instance.
            By continuing our session in ChatGPT, I don't have to re-enter the previous code or prompts.

          blockquote.pre.
            Create a Razor Page (Articles.cshtml and Articles.cshtml.cs) that gets the service through DI and displays all Articles.

          p.
            This returns the code for the Razor page.

          pre.code.
            // Articles.cshtml
            @page
            @model ArticlesModel
            @{
              ViewData["Title"] = "Articles";
            }
            &lt;h1&gt;@ViewData[&quot;Title&quot;]&lt;/h1&gt;

            &lt;table class=&quot;table&quot;&gt;
              &lt;thead&gt;
                &lt;tr&gt;
                  &lt;th&gt;Title&lt;/th&gt;
                  &lt;th&gt;Description&lt;/th&gt;
                  &lt;th&gt;Link&lt;/th&gt;
                &lt;/tr&gt;
              &lt;/thead&gt;
              &lt;tbody&gt;
              @foreach (var Article in Model.Articles)
              {
                &lt;tr&gt;
                  &lt;td&gt;@Article.Title&lt;/td&gt;
                  &lt;td&gt;@Article.Description&lt;/td&gt;
                  &lt;td&gt;&lt;a href=&quot;@Article.Link&quot; target=&quot;_blank&quot;&gt;Visit&lt;/a&gt;&lt;/td&gt;
                &lt;/tr&gt;
              }
              &lt;/tbody&gt;
              &lt;/table&gt;

            // Articles.cshtml.cs
            using Microsoft.AspNetCore.Mvc;
            using Microsoft.AspNetCore.Mvc.RazorPages;
            using System.Collections.Generic;

            public class ArticlesModel : PageModel
            {
              private readonly ArticleService _ArticleService;
              public ArticlesModel(ArticleService ArticleService)
              {
                _ArticleService = ArticleService;
              }
              public List&lt;ArticleModel&gt; Articles { get; private set; }
              public void OnGet()
              {
                Articles = _ArticleService.GetArticles();
              }
            }
        dt Step 3: Configure Article Service for Dependency Injection
        dd
          p.
            Now that we have the service and Razor page, we can register the service and point to the Articles.JSON file.
        pre.code.
          // Program.cs
          // Register Services
          builder.Services.AddSingleton&gt;ArticleService&lt;(provider =&gt;
          {
            return new ArticleService(Path.GetFullPath(Path.Combine("..", "..", "src", "articles.json")));
          });
          builder.Services.AddSingleton&gt;ArticleService&lt;(provider =>
          {
            return new ArticleService(Path.GetFullPath(Path.Combine("..", "..", "src", "Articles.json")));
          });

          // Add a Virtual Directory for our images
          app.UseStaticFiles(new StaticFileOptions
          {
            FileProvider = new PhysicalFileProvider(Path.GetFullPath(Path.Combine("..", "..", "src", "assets", "img"))),
            RequestPath = "/assets/img"
          });

      p.
        And there you have it! I have created an interface to manage Articles in my blog using ASP.NET Core.
        With the power of ChatGPT prompts, I was able to quickly generate the necessary code snippets
        for the Article model, service, and Razor Page. Now I can efficiently manage Articles on my blog.

      .image-container
        picture
          img.text-center.img-fluid(src='/assets/img/MarkHazleton-ChatGPT-CMSArticleEdit.png' alt='Edit Articles' title='Edit Articles' width='100%')



      h3 Creating an Interface to Manage Projects
      p.
        I have a JSON file that lists all my projects that I use to showcase various projects,
        managing the project data efficiently would be a bonus.
        Let's walk through the steps to create an interface that allows me to manage project data stored in a `projects.json` file.
        To get going quickly, I will utilize the power of ChatGPT prompts to generate code snippets along the way.
      p.
        To see the full Chat GPT log visit the shared
        <a href='https://chat.openai.com/share/39e0c084-94b4-4d43-8362-a7dbf80cca72' target='_blank'>Chat GPT Session</a>
      dl
        dt Step 1: Create the Project Model and Service
        dd
          p.
            The first step is to create a C# model that represents a project.
            We'll create a `ProjectModel` class to hold project information.
          p.
            We can use the ChatGPT prompt to help generate the code for this.

          blockquote.pre.
            Create a model class called ProjectModel in C# for the following JSON file.
            Create a Service to maintain the JSON file which consists of a list of the Project Model class. Here is the JSON for the projects.
            [
              {
                "image": "assets/img/frogsfolly.png",
                "p": "Frogsfolly",
                "d": " My first website, setup to share photos with my family but is now a 'Kitchen Sink' of demos and test ideas. The site is built with  Web Project Mechanics CMS.",
                "h": "https://frogsfolly.com"
              },
            }
          p.
            This returns the code for the Project Model.
          pre.code.
            // ProjectModel.cs
            public class ProjectModel
            {
              public string Image { get; set; }
              public string Title { get; set; }
              public string Description { get; set; }
              public string Link { get; set; }
            }
          p.
            And the code for the Project Service.
          pre.code.
            // ProjectService.cs
            using System.Collections.Generic;
            using System.IO;
            using Newtonsoft.Json;

            public class ProjectService
            {
              private readonly string _jsonFilePath;
              public ProjectService(string jsonFilePath)
              {
                _jsonFilePath = jsonFilePath;
              }

              public List&lt;ProjectModel&gt; GetProjects()
              {
                using (StreamReader reader = new StreamReader(_jsonFilePath))
                {
                  string json = reader.ReadToEnd();
                  List&lt;ProjectModel&gt; projects = JsonConvert.DeserializeObject&lt;List&lt;ProjectModel&gt;&gt;(json);
                  return projects;
                }
              }

              public void SaveProjects(List&lt;ProjectModel&gt; projects)
              {
                string json = JsonConvert.SerializeObject(projects, Formatting.Indented);
                File.WriteAllText(_jsonFilePath, json);
              }
            }

        dt Step 2: Create a Razor Page for Managing Projects
        dd
          p.
            Now let's create a Razor Page to manage the projects.
            We'll use dependency injection to get the `ProjectService` instance.
            By continuing our session in ChatGPT, I don't have to re-enter the previous code or prompts.

          blockquote.pre.
            Create a Razor Page (Projects.cshtml and Projects.cshtml.cs) that gets the service through DI and displays all projects.

          p.
            This returns the code for the Razor page.

          pre.code.
            // Projects.cshtml
            @page
            @model ProjectsModel
            @{
              ViewData["Title"] = "Projects";
            }
            &lt;h1&gt;@ViewData[&quot;Title&quot;]&lt;/h1&gt;

            &lt;table class=&quot;table&quot;&gt;
              &lt;thead&gt;
                &lt;tr&gt;
                  &lt;th&gt;Image&lt;/th&gt;
                  &lt;th&gt;Title&lt;/th&gt;
                  &lt;th&gt;Description&lt;/th&gt;
                  &lt;th&gt;Link&lt;/th&gt;
                &lt;/tr&gt;
              &lt;/thead&gt;
              &lt;tbody&gt;
              @foreach (var project in Model.Projects)
              {
                &lt;tr&gt;
                  &lt;td&gt;&lt;img src=&quot;@project.Image&quot; alt=&quot;@project.Title&quot; width=&quot;100&quot; /&gt;&lt;/td&gt;
                  &lt;td&gt;@project.Title&lt;/td&gt;
                  &lt;td&gt;@project.Description&lt;/td&gt;
                  &lt;td&gt;&lt;a href=&quot;@project.Link&quot; target=&quot;_blank&quot;&gt;Visit&lt;/a&gt;&lt;/td&gt;
                &lt;/tr&gt;
              }
              &lt;/tbody&gt;
              &lt;/table&gt;

            // Projects.cshtml.cs
            using Microsoft.AspNetCore.Mvc;
            using Microsoft.AspNetCore.Mvc.RazorPages;
            using System.Collections.Generic;

            public class ProjectsModel : PageModel
            {
              private readonly ProjectService _projectService;
              public ProjectsModel(ProjectService projectService)
              {
                _projectService = projectService;
              }
              public List&lt;ProjectModel&gt; Projects { get; private set; }
              public void OnGet()
              {
                Projects = _projectService.GetProjects();
              }
            }
        dt Step 3: Configure Project Service for Dependency Injection
        dd
          p.
            Now that we have the service and Razor page, we can register the servive and point to the Projects.JSON file.
        pre.code.
          // Program.cs
          // Register Services
          builder.Services.AddSingleton&gt;ArticleService&lt;(provider =&gt;
          {
            return new ArticleService(Path.GetFullPath(Path.Combine("..", "..", "src", "articles.json")));
          });
          builder.Services.AddSingleton&gt;ProjectService&lt;(provider =>
          {
            return new ProjectService(Path.GetFullPath(Path.Combine("..", "..", "src", "projects.json")));
          });

          // Add a Virtual Directory for our images
          app.UseStaticFiles(new StaticFileOptions
          {
            FileProvider = new PhysicalFileProvider(Path.GetFullPath(Path.Combine("..", "..", "src", "assets", "img"))),
            RequestPath = "/assets/img"
          });


      p.
        And there you have it! You've successfully created an interface to manage projects in your personal blog using ASP.NET Core.
        With the power of ChatGPT prompts, you were able to quickly generate the necessary code snippets
        for the project model, service, and Razor Page. Now you can efficiently manage and showcase your projects on your blog.

      .image-container
        picture
          img.text-center.img-fluid(src='/assets/img/MarkHazleton-ChatGPT-CMSProjectDisplay.png' alt='Display Projects' title='Display Projects' width='100%')


      h3.
        Conclusion
      p.
        In the world of web development, the allure of crafting bespoke solutions is undeniable.
        Whether it's building a framework to streamline project management or creating a CMS to manage blog articles,
        the journey is characterized by passion, creativity, and a commitment to improving workflows.  It is a variation
        on the addage "necessity is the mother of invention", in this case the necessity is the desire to create a
        better solution to a problem.

      p.
        Stay tuned for more articles on leveraging the capabilities of modern web development
        and AI-driven tools to enhance your projects and coding experience.


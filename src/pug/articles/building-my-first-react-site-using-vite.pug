extends ../layouts/articles

block pagehead
  title Building My First React Site Using Vite
  meta(name='description', content='Learn how to quickly build and deploy a React site using Vite and GitHub Pages, including troubleshooting common issues like CORS.')
  meta(name="keywords" content="Vite, React, GitHub Pages, CORS, deployment, setup")
  meta(name='author', content='Mark Hazleton')
  link(rel='canonical', href='https://markhazleton.com/articles/building-my-first-react-site-using-vite.html')

block layout-content

  section#post.painteddesert-section.painteddesert-section-background
    .painteddesert-section-content
      p.fw-bold.text-primary.text-center.bg-primary.text-white
        a.fw-bold.text-primary.text-center.bg-primary.text-white(href='https://github.com/markhazleton/ReactSparkPortfolio' target="_blank" title='The full source code for the ReactSparkPortfolio is available on GitHub') The full source code for the ReactSparkPortfolio is available on GitHub
      h1 Building My First React Site Using Vite and GitHub
      h2.subheading.mb-3 A step-by-step guide to setting up and deploying a React project
      p.
        I recently created a React portfolio project using Vite and deployed it to GitHub Pages.
        Since this was my first time building with React and TypeScript, I learned a lot along
        the way.
      p.
        Vite offers an incredibly fast and efficient way to create and deploy React sites. In this guide,
        we will walk through the entire process, including setting up Vite, configuring it for GitHub Pages,
        handling CORS issues, and deploying the final product.

      dl
        dt Initial Project Setup
        dd
          p.
            Start by using Vite's project scaffolding for React. This sets up the initial folder structure
            and installs dependencies.
          pre.language-bash
            code.language-bash.
              npm create vite@latest
              cd ReactSparkPortfolio
              npm install

        dt Writing and Organizing My React Components
        dd
          p.
            After setting up the project, I created components for my portfolio. I wanted a simple, clean
            layout with sections for Home, About, Projects, and Contact.
          pre.language-typescript
            code.language-typescript.
              import React, { useState } from 'react';
              import Header from './components/Header';
              import Hero from './components/Hero';
              import About from './components/About';
              import Projects from './components/Projects';
              import Contact from './components/Contact';
              import Footer from './components/Footer';

              const App: React.FC = () => {
                const [activeSection, setActiveSection] = useState<string>('home');

                const handleSectionChange = (section: string) => {
                  setActiveSection(section);
                };

                return (
                  <div className="d-flex flex-column min-vh-100">
                    <Header onSectionChange={handleSectionChange} />
                    <main className="flex-grow-1 pt-5 mt-5 container">
                      <div className="row justify-content-center">
                        <div className="col-md-10">
                          {activeSection === 'home' && <Hero />}
                          {activeSection === 'about' && <About />}
                          {activeSection === 'projects' && <Projects />}
                          {activeSection === 'contact' && <Contact />}
                        </div>
                      </div>
                    </main>
                    <Footer />
                  </div>
                );
              };

              export default App;

        dt Configure Vite for GitHub Pages
        dd
          p.
            Vite builds the production files into a "dist" folder by default. For GitHub Pages, however,
            we need to modify Vite’s configuration to output into the "docs" folder.  This makes setting up
            the GitHub Pages deployment easier as it serves the site from the "docs" folder by default.
          pre.language-typescript
            code.language-typescript.
              import { defineConfig } from "vite";
              import react from "@vitejs/plugin-react";

              export default defineConfig({
                base: "./",
                build: {
                  outDir: "docs",
                },
                plugins: [react()],
              });

        dt Serving Static Assets and Handling CORS Issues
        dd
          p.
            Fetching data from external sources during development can cause CORS issues. One way to
            resolve this is by moving static files like rss.xml to Vite's public folder, which serves static assets directly.
          pre.language-typescript
            code.language-typescript.
              const fetchRSSFeed = async () => {
                const response = await fetch('/rss.xml');
                const rssData = await response.text();

                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(rssData, 'application/xml');
              };

        dt Adding the Articles Component
        dd
          p.
            To display content from an RSS feed, create an "Articles" component that fetches and parses the RSS XML
            file, rendering article titles and links.
          p.
            This TypeScript code defines a React functional component that dynamically fetches and displays a list of articles from an RSS feed.
            The component uses React’s useState hook to create a state variable that holds the articles, which is initialized as an empty array.
            The state is updated once the RSS feed is fetched and parsed.
            Additionally, useEffect is used to ensure that the fetch operation happens when the component first renders.
            Since useEffect is invoked with an empty dependency array, it acts like a componentDidMount lifecycle event,
            executing the fetch operation only once when the component is mounted.
          p.
            The RSS feed is fetched asynchronously using the native fetch API,
            targeting the /rss.xml endpoint on the server.
            After retrieving the raw XML data as plain text, the code uses DOMParser to parse this text into an XML structure.
            Once parsed, the &lt;item> elements, which represent individual articles, are extracted. For each &lt;item>,
            the component pulls relevant data such as the title, link, and publication date by accessing the corresponding child elements.
            This extracted information is stored in a structured array, which is then used to update the component’s state.
          p.
            Once the state is updated with the parsed articles, the component renders a list of articles in the browser.
            Each article is displayed as a clickable link along with its publication date.
            The component efficiently maps through the state array of articles to dynamically generate the list items,
            ensuring that the data is presented as soon as it is fetched and parsed.
            By combining useEffect for side effects and useState for managing data, the component handles asynchronous
            data fetching and re-renders itself when new data becomes available,
            creating a simple and effective way to display RSS feed content in a React application.

          pre.language-typescript
            code.language-typescript.
              import React, { useEffect, useState } from 'react';

              const Articles: React.FC = () => {
                const [articles, setArticles] = useState<any[]>([]);

                useEffect(() => {
                  const fetchRSSFeed = async () => {
                    const response = await fetch('/rss.xml');
                    const rssData = await response.text();

                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(rssData, 'application/xml');
                    const items = xmlDoc.getElementsByTagName('item');

                    const parsedArticles = Array.from(items).map(item => ({
                      title: item.getElementsByTagName('title')[0].textContent,
                      link: item.getElementsByTagName('link')[0].textContent,
                      pubDate: item.getElementsByTagName('pubDate')[0].textContent,
                    }));

                    setArticles(parsedArticles);
                  };
                  fetchRSSFeed();
                }, []);

                return (
                  <div>
                    <h2>Latest Articles</h2>
                    <ul>
                      {articles.map((article, index) => (
                        <li key={index}>
                          <a href={article.link}>{article.title}</a> - {article.pubDate}
                        </li>
                      ))}
                    </ul>
                  </div>
                );
              };

              export default Articles;

        dt Deploying the Site on GitHub Pages
        dd
          p.
            Deploying a Vite site to GitHub Pages involves configuring a GitHub Actions workflow.
            This automates the process and pushes the build output to the "docs" folder on every push.
          pre.language-yaml
            code.language-yaml.
              name: Deploy React App to GitHub Pages

              on:
                push:
                  branches:
                    - main

              jobs:
                build:
                  runs-on: ubuntu-latest
                  steps:
                    - name: Checkout code
                      uses: actions/checkout@v2

                    - name: Set up Node.js
                      uses: actions/setup-node@v2
                      with:
                        node-version: '16'

                    - name: Install dependencies
                      run: npm install

                    - name: Build the project
                      run: npm run build

                    - name: Deploy to GitHub Pages
                      uses: peaceiris/actions-gh-pages@v3
                      with:
                        github_token: ${{ secrets.GITHUB_TOKEN }}
                        publish_dir: ./docs

        dt Final Thoughts
        dd
          p.
            Vite simplifies React development with features like instant hot module replacement and minimal configuration.
            With just a few steps, you can deploy a project using GitHub Pages. Even with common issues like CORS, Vite
            offers flexible solutions that help you get your project online quickly.


      h1 Learn TypeScript with Code Examples
      h2.subheading.mb-3 Explore TypeScript concepts through examples and interactive code

      // Bootstrap Accordion for TypeScript Concepts
      .accordion#typescriptConceptsAccordion
        // Concept 1: Basic Type Annotations
        .accordion-item
          h2.accordion-header#headingOne
            button.accordion-button.collapsed(type="button", data-bs-toggle="collapse", data-bs-target="#collapseOne" aria-expanded="false", aria-controls="collapseOne")
              | Basic Type Annotations
          .accordion-collapse.collapse#collapseOne(aria-labelledby="headingOne" data-bs-parent="#typescriptConceptsAccordion")
            .accordion-body
              p Type annotations are a fundamental feature of TypeScript. They help you specify the types of variables, function parameters, and return values.
              p Learn how to use TypeScript’s type annotations.
              pre.language-typescript
                code.language-typescript.
                  let message: string = "Hello, TypeScript!";
                  let isDone: boolean = false;
                  let count: number = 42;
              p Output:
              pre.language-bash
                code.language-bash.
                  Hello, TypeScript!
                  false
                  42

        // Concept 2: Functions with Typed Parameters and Return Types
        .accordion-item
          h2.accordion-header#headingTwo
            button.accordion-button.collapsed(type="button", data-bs-toggle="collapse", data-bs-target="#collapseTwo" aria-expanded="false", aria-controls="collapseTwo")
              | Functions with Typed Parameters and Return Types
          .accordion-collapse.collapse#collapseTwo(aria-labelledby="headingTwo" data-bs-parent="#typescriptConceptsAccordion")
            .accordion-body
              p.
                Type annotations in TypeScript allow developers to explicitly define the data types for variables, function arguments,
                and return values. This proactive approach helps catch potential errors early in the development process,
                promoting the use of correct data types and improving overall code stability.
                Unlike JavaScript, which is more flexible with data types, TypeScript enforces stricter rules,
                bringing more predictability and helping to prevent unexpected bugs.
                In the context of React Native, type annotations play a critical role in managing components and their props.
                By ensuring props are correctly typed, they help reduce runtime errors.
                Type annotations also simplify state management and API interactions by enforcing data structures and identifying mismatches early on.
                Overall, they contribute to a smoother development experience, especially with TypeScript’s helpful autocompletion and type inference features.
              p.
                Type annotations in my App.tsx file enhance code quality and developer experience by ensuring type safety and improving readability.
                Integrating these annotations fosters a more reliable and maintainable codebase. Here are three key points:
              ul
                li Component Definition: The React.FC annotation in const App: React.FC identifies App as a React functional component, ensuring type safety for any props it might receive.
                li State Management: Using &lt;string&gt; in useState&lt;string&gt;('home') ensures that activeSection is always treated as a string, catching type errors early and improving code robustness.
                li Function Parameters: Annotating parameters like (section: string) in handleSectionChange ensures that only strings are passed to this function, preventing potential bugs from incorrect argument types.

              pre.language-typescript
                code.language-typescript.
                  const App: React.FC = () => {
                    // State to keep track of which section is active
                    const [activeSection, setActiveSection] = useState<string>('home');
                    // Handler to update the active section based on navigation clicks
                    const handleSectionChange = (section: string) => {
                      setActiveSection(section);
                    };
                    return (
                      <div className="d-flex flex-column min-vh-100">
                        <Header onSectionChange={handleSectionChange} />
                        <main className="flex-grow-1 pt-5 mt-5 container">
                          <div className="row justify-content-center">
                            <div className="col-md-10">
                              {activeSection === 'home' && <Hero />}
                              {activeSection === 'about' && <About />}
                              {activeSection === 'projects' && <Projects />}
                              {activeSection === 'contact' && <Contact />}
                            </div>
                          </div>
                        </main>
                        <Footer />
                      </div>
                    );
                  }

        // Concept 3: Optional and Default Parameters
        .accordion-item
          h2.accordion-header#headingThree
            button.accordion-button.collapsed(type="button", data-bs-toggle="collapse", data-bs-target="#collapseThree" aria-expanded="false", aria-controls="collapseThree")
              | Optional and Default Parameters
          .accordion-collapse.collapse#collapseThree(aria-labelledby="headingThree" data-bs-parent="#typescriptConceptsAccordion")
            .accordion-body
              p.
                In TypeScript, function parameters can be optional or have default values.  Optional and default parameters in TypeScript provide a way to make
                functions and components more flexible and robust:
              dl
                dt Optional Parameters
                dd These allow you to call functions without providing all arguments, ensuring smoother function execution even with missing inputs.
                dt Default Parameters
                dd They provide a fallback value if no argument is supplied, preventing undefined values and potential errors.
                dt Type Safety
                dd Both optional and default parameters enhance code readability and reliability by explicitly defining the expected types and values, reducing bugs and improving maintainability.
                p.
                  In Hero.tsx, the concept of optional and default parameters is applied to enhance flexibility and robustness.
                  The component accepts an optional profileData parameter, allowing it to function seamlessly even when this data isn't provided.
                  If profileData is not available, the function defaults to a predefined defaultProfile, ensuring the component always has data to render.
                  This approach reduces the risk of errors due to missing information and maintains the smooth operation of the component
                  under various circumstances. Ultimately, it exemplifies how TypeScript's optional and default parameters can create more adaptable and resilient code.
              pre.language-typescript
                code.language-typescript.
                  import React from 'react';
                  import defaultProfile from '../data/profile.json'; // Adjust the path according to where you place profile.json

                  interface Profile {
                  name: string;
                  introduction: string;
                  ctaLink: string;
                  ctaText: string;
                  }

                  const renderHero = (profileData?: Profile) => {
                  const profile = profileData || defaultProfile;

                  // Check if profile is null or empty
                  if (!profile || Object.keys(profile).length === 0) {
                    return (
                    <section id="hero" className="bg-secondary text-white text-center py-5">
                      <div className="container">
                      <div className="row justify-content-center">
                        <div className="col-md-8">
                        <h1 className="display-4">Error</h1>
                        <p className="lead">Profile data is missing or unavailable.</p>
                        </div>
                      </div>
                      </div>
                    </section>
                    );
                  }
                  return (
                    <section id="hero" className="bg-secondary text-white text-center py-5">
                    <div className="container">
                      <div className="row justify-content-center">
                      <div className="col-md-8">
                        <h1 className="display-4">{profile.name}</h1>
                        <p className="lead">{profile.introduction}</p>
                        <a href={profile.ctaLink} className="btn btn-primary btn-lg mt-4">
                        {profile.ctaText}
                        </a>
                      </div>
                      </div>
                    </div>
                    </section>
                  );
                  };

                  const Hero: React.FC<{ profileData?: Profile }> = ({ profileData }) => {
                  return renderHero(profileData);
                  };

                  export default Hero;




        // Concept 4: Interfaces
        .accordion-item
          h2.accordion-header#headingFour
            button.accordion-button.collapsed(type="button", data-bs-toggle="collapse", data-bs-target="#collapseFour" aria-expanded="false", aria-controls="collapseFour")
              | Interfaces
          .accordion-collapse.collapse#collapseFour(aria-labelledby="headingFour" data-bs-parent="#typescriptConceptsAccordion")
            .accordion-body
              p.
                TypeScript interfaces are powerful tools that define the structure of an object, detailing the expected properties and their types.
                They enforce type-checking, ensuring that any object adhering to the interface meets these criteria, thus reducing runtime errors.
                In the Articles.tsx file, the Article interface outlines the structure for an article object, specifying that each article
                should have a title, link, and pubDate, all of which are strings.
              p.
                This interface is then used in the state management, ensuring that the articles state array contains objects that conform to this structure.
                By defining the shape of the article data upfront, the code becomes more predictable and easier to maintain, providing clear expectations for the data being handled.
              pre.language-typescript
                code.language-typescript.
                  interface Article {
                  title: string;
                  link: string;
                  pubDate: string;
                  }
        // Concept 5: Type Aliases
        .accordion-item
          h2.accordion-header#headingFive
            button.accordion-button.collapsed(type="button", data-bs-toggle="collapse", data-bs-target="#collapseFive" aria-expanded="false", aria-controls="collapseFive")
              | Type Aliases
          .accordion-collapse.collapse#collapseFive(aria-labelledby="headingFive" data-bs-parent="#typescriptConceptsAccordion")
            .accordion-body
              p.
                Type aliases allow you to define custom types, which can make your code more readable and reusable.
                A Type Alias in TypeScript provides a new name for any type, like a shorthand or simplification.
                This could be a primitive type, a union of types, an object type, or any other structure.
                It's a way to make complex types more readable and easier to manage.
              p.
                The keyword type is used to create these aliases, essentially giving a new name to an existing type or a complex structure.
                This is especially useful for making your code cleaner and more understandable,
                particularly when dealing with intricate type definitions.
                They don't add any new functionality or behavior to the type itself—they just give it a more convenient or meaningful name.
              p.
                On the other hand, the type keyword in TypeScript is also used to define these Type Aliases.
                So when we talk about 'type' in TypeScript, it often refers to the process of creating these aliases,
                encapsulating the concept of type definitions that enhance code clarity and maintenance.
                Here is a type alias example in TypeScript that defines an article.
              pre.language-typescript
                code.language-typescript.
                  type Article = {
                    title: string;
                    link: string;
                    pubDate: string;
                  };
        // Concept 6: Union and Intersection Types
        .accordion-item
          h2.accordion-header#headingSix
            button.accordion-button.collapsed(type="button", data-bs-toggle="collapse", data-bs-target="#collapseSix" aria-expanded="false", aria-controls="collapseSix")
              | Union and Intersection Types
          .accordion-collapse.collapse#collapseSix(aria-labelledby="headingSix" data-bs-parent="#typescriptConceptsAccordion")
            .accordion-body
              p Union types allow a variable to hold multiple types, while intersection types combine types.
              p Learn to use union and intersection types in TypeScript.
              pre.language-typescript
                code.language-typescript.
                  type StringOrNumber = string | number;
                  let value: StringOrNumber = "Hello";

                  interface Person {
                    name: string;
                  }

                  interface Employee {
                    employeeId: number;
                  }

                  type Worker = Person & Employee;

                  const worker: Worker = {
                    name: "Alice",
                    employeeId: 123
                  };

        // Concept 7: Generics
        .accordion-item
          h2.accordion-header#headingSeven
            button.accordion-button.collapsed(type="button", data-bs-toggle="collapse", data-bs-target="#collapseSeven" aria-expanded="false", aria-controls="collapseSeven")
              | Generics
          .accordion-collapse.collapse#collapseSeven(aria-labelledby="headingSeven" data-bs-parent="#typescriptConceptsAccordion")
            .accordion-body
              p Generics allow you to write functions, interfaces, and classes that can work with any data type, providing flexibility with type safety.
              p Learn how to use Generics for reusable, type-safe components.
              pre.language-typescript
                code.language-typescript.
                  function identity<T>(arg: T): T {
                    return arg;
                  }

        // Concept 8: Type Assertions
        .accordion-item
          h2.accordion-header#headingEight
            button.accordion-button.collapsed(type="button", data-bs-toggle="collapse", data-bs-target="#collapseEight" aria-expanded="false", aria-controls="collapseEight")
              | Type Assertions
          .accordion-collapse.collapse#collapseEight(aria-labelledby="headingEight" data-bs-parent="#typescriptConceptsAccordion")
            .accordion-body
              p Type assertions tell the compiler to treat a variable as a specific type. This is helpful when you know more about the type than TypeScript does.
              p Learn to assert types in TypeScript for more control over type checking.
              pre.language-typescript
                code.language-typescript.
                  let someValue: any = "This is a string";
                  let strLength: number = (someValue as string).length;

        // Concept 9: Enums
        .accordion-item
          h2.accordion-header#headingNine
            button.accordion-button.collapsed(type="button", data-bs-toggle="collapse", data-bs-target="#collapseNine" aria-expanded="false", aria-controls="collapseNine")
              | Enums
          .accordion-collapse.collapse#collapseNine(aria-labelledby="headingNine" data-bs-parent="#typescriptConceptsAccordion")
            .accordion-body
              p Enums define a set of named constants, which can help manage related values.
              p Learn to create and use Enums for defining sets of constants.
              pre.language-typescript
                code.language-typescript.
                  enum Direction {
                    Up = 1,
                    Down,
                    Left,
                    Right
                  }

                  let currentDirection: Direction = Direction.Up;

        // Concept 10: React Native Props with TypeScript
        .accordion-item
          h2.accordion-header#headingTen
            button.accordion-button.collapsed(type="button", data-bs-toggle="collapse", data-bs-target="#collapseTen" aria-expanded="false", aria-controls="collapseTen")
              | React Native Props with TypeScript
          .accordion-collapse.collapse#collapseTen(aria-labelledby="headingTen" data-bs-parent="#typescriptConceptsAccordion")
            .accordion-body
              p In React Native, TypeScript is particularly useful for typing props and state in functional components.
              p Learn to use TypeScript to define props in React Native components.
              pre.language-typescript
                code.language-typescript.
                  interface GreetingProps {
                    name: string;
                    age?: number;
                  }

                  const Greeting: React.FC<GreetingProps> = ({ name, age }) => {
                    return (
                      <View>
                        <Text>Hello, {name}!</Text>
                        {age && <Text>You are {age} years old.</Text>}
                      </View>
                    );
                  };
              p.
                In this example, name is a required prop, and age is optional. TypeScript will enforce the correct usage of these props when using the Greeting component.
        // Concept 11: TypeScript Classes
        .accordion-item
          h2.accordion-header#headingEleven
            button.accordion-button.collapsed(type="button", data-bs-toggle="collapse", data-bs-target="#collapseEleven" aria-expanded="false", aria-controls="collapseEleven")
              | TypeScript Classes
          .accordion-collapse.collapse#collapseEleven(aria-labelledby="headingEleven" data-bs-parent="#typescriptConceptsAccordion")
            .accordion-body
              p.
                TypeScript classes are a way to create reusable blueprints for objects, encapsulating both data and behavior.
                They bring an object-oriented approach to TypeScript, much like classes in C#.
                In the context the Article class, TypeScript classes allow you to define the structure and functionality of an Article.
                The class encapsulates properties like title, link, and pubDate, which are all essential attributes of an article.
                By defining these properties in the class, you ensure that every instance of Article has a consistent structure.
              p.
                Classes also allow you to define a constructor, a special method used for creating and initializing objects of the class.
                In the Article class, the constructor takes parameters that correspond to the article's properties
                and assigns them to the class's properties.
                This ensures that whenever you create a new Article, you provide the necessary data for title, link, and pubDate.
              p.
                TypeScript classes can include methods that define behaviors related to the class's data.
                In the Article class, for example, you might have a method called getSummary that returns a
                formatted string summarizing the article's information.
                This method encapsulates the behavior related to presenting an article's summary, keeping the logic within the class where it belongs.
              p.
                The use of TypeScript classes also supports inheritance,
                where a new class can inherit properties and methods from an existing class.
                This promotes code reuse and allows for the creation of more specialized classes that build on the functionality of base classes.
              p.
                Overall, TypeScript classes like Article provide a powerful way to define and work with structured data,
                offering clear, maintainable, and scalable code. They combine data and behavior in a way that
                aligns with object-oriented principles, making your TypeScript code more robust and easier to understand.

              pre.language-typescript
                code.language-typescript.
                  class Article {
                    title: string;
                    link: string;
                    pubDate: string;

                    constructor(title: string, link: string, pubDate: string) {
                      this.title = title;
                      this.link = link;
                      this.pubDate = pubDate;
                    }

                    // Method to get a formatted article summary
                    getSummary(): string {
                      return `${this.title} was published on ${this.pubDate}. Read more at ${this.link}`;
                    }
                  }

                  // Example usage
                  const article = new Article('New TypeScript Release', 'https://typescriptlang.org', '2024-10-12');
                  console.log(article.getSummary());



      p.
        These TypeScript code samples cover core features that will improve the development experience for new developers.
        They ensure safer, more predictable code, especially in React Native projects where maintaining clarity in component structures is essential.


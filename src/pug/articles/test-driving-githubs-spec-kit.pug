extends ../layouts/modern-layout

//- Import standardized article mixins
include ../modules/article-mixins

block layout-content
  br
  // Hero Section
  section.bg-gradient-primary.py-5
    .container
      .row.align-items-center
        .col-lg-10.mx-auto.text-center
          h1.display-4.fw-bold.mb-3
            i.bi.bi-lightbulb.me-3
            | GitHub Spec Kit
          h2.mb-4 Test Driving GitHub Spec Kit: Living Documentation

  //- Main Article Content
  article#main-article
    .container
      .row
        .col-lg-8.mx-auto

          p.lead.mb-4.text-center.mt-4.
            I was skeptical. After years of dealing with outdated documentation, 
            the promise of "living documentation" sounded like another attempt to solve an age-old problem. 
            Then I tried it on a production NuGet package. Here's what actually happened.

          //- Table of contents
          +tableOfContents([
            { href: '#executive-summary', text: 'Executive Summary' },
            { href: '#documentation-drift', text: 'The Documentation Drift Problem' },
            { href: '#what-is-spec-kit', text: 'What Is Spec Kit?' },
            { href: '#my-experiment', text: 'My Experiment: Two Real Specs' },
            { href: '#github-stats-spark', text: 'Deep Dive: GitHub Stats Spark' },
            { href: '#what-i-learned', text: 'What I Learned Writing Specs' },
            { href: '#feedback-examples', text: 'The Feedback Loop in Practice' },
            { href: '#faq', text: 'Frequently Asked Questions' },
            { href: '#the-awkward-part', text: 'The Awkward Part' },
            { href: '#conclusion', text: 'Should You Try It?' }
          ])

          section#executive-summary.mb-5
            h2.h3.mb-4
              i.bi.bi-file-earmark-text.me-2
              | Executive Summary

            p.lead.mb-4.
              Every developer knows the pattern: Design document says one thing, code does another, 
              six months later nobody knows which is correct. 
              Waterfall specs died when code changed. 
              Agile seems to have thrown out specs entirely and instead focused on incremental changes with 
              little updates to the full feature set documentation. 
              Both failed for the same reason—humans won't maintain documentation when it's divorced from implementation.

            p.mb-4.
              GitHub Spec Kit closes the feedback loop: 
              AI agents update documentation when implementation diverges, so specs become living artifacts instead of 
              shelf-ware. The ROI isn't faster development—it's specs that still accurately describe the codebase 
              three months later.

            .card.mb-4
              .card-header.bg-light
                h5.card-title.mb-0
                  i.bi.bi-trophy.me-2
                  | What You'll Learn
              .card-body
                ul.mb-0
                  li
                    strong Solving documentation drift:
                    |  How AI agents close the feedback loop humans never could—specs stay synchronized with implementation
                  li
                    strong Institutional knowledge persistence:
                    |  Path resolution patterns, warning remediation strategies, architectural decisions captured in markdown that survives team turnover
                  li
                    strong The feedback cycle:
                    |  AI generates → human fixes → human tells AI to update specs → knowledge persists forever
                  li
                    strong When it matters:
                    |  Libraries, APIs, multi-year projects where tribal knowledge creates single points of failure
                  li
                    strong Real metrics:
                    |  Implementation: 7 hours (same as always). Documentation sync: 20 minutes (vs. never). Result: Zero documentation debt.

            .card.mb-4
              .card-header.bg-light
                h5.card-title.mb-0
                  i.bi.bi-people.me-2
                  | Who This Is For
              .card-body
                ul.mb-0
                  li
                    strong Solutions Architects:
                    |  Translate business requirements into technology with precision
                  li
                    strong Development Teams:
                    |  Escape the prompt-generate-debug cycle with structured workflows
                  li
                    strong Engineering Leaders:
                    |  Build institutional knowledge that scales beyond individual contributors
                  li
                    strong .NET Developers:
                    |  Practical patterns for NuGet packages, documentation, and quality enforcement

            .alert.alert-info.mb-0
              h6.alert-heading
                i.bi.bi-link-45deg.me-2
                | References
              ul.mb-0
                li
                  | GitHub Spec Kit: 
                  a(href='https://github.com/github/spec-kit', target='_blank', rel='noopener') https://github.com/github/spec-kit
                li
                  | GitHub Copilot: 
                  a(href='https://github.com/features/copilot', target='_blank', rel='noopener') https://github.com/features/copilot
                li
                  | WebSpark.HttpClientUtility Repository: 
                  a(href='https://github.com/markhazleton/WebSpark.HttpClientUtility', target='_blank', rel='noopener') .NET NuGet package example
                li
                  | GitHub Stats Spark Repository: 
                  a(href='https://github.com/markhazleton/github-stats-spark', target='_blank', rel='noopener') Complete SpecKit + Claude + Copilot workflow
                li
                  | GitHub Actions: 
                  a(href='https://docs.github.com/actions', target='_blank', rel='noopener') https://docs.github.com/actions
                li
                  | NuGet Publishing: 
                  a(href='https://learn.microsoft.com/nuget/create-packages/publish-a-package', target='_blank', rel='noopener') https://learn.microsoft.com/nuget/create-packages/publish-a-package

          section#documentation-drift.mb-5
            h2.h3.mb-4
              i.bi.bi-arrow-right-circle.me-2
              | The Documentation Drift Problem

            p.mb-3.
              Every codebase has specs that lie. They said one thing at design time, developers changed it during implementation, and nobody updated the docs. Waterfall tried to solve this with upfront perfection—specs froze before coding started. Agile gave up entirely—"working software over comprehensive documentation."

            p.mb-3.
              Both failed for the same reason: humans won't maintain documentation when it's divorced from implementation. The feedback loop is too expensive.

            p.mb-3.
              I spent 8 years at EDS maintaining three-ring binders of waterfall specs. The specs were beautiful at handoff. Three months later, they were fiction. The human cost of keeping specs synchronized with code was unsustainable.

            h3.h5.mb-3 What If AI Could Close the Loop?

            p.mb-3.
              GitHub Spec Kit offers something different: AI agents that update documentation when implementation changes.

            p.mb-3.
              The cycle: AI generates code from spec → human fixes what's wrong → human tells AI "update the specs to match reality" → specs evolve instead of ossifying.

            p.mb-0.
              I tested this on a production NuGet package. Two features, 7 hours of work, 136 files changed. Every deviation from the original plan became a permanent improvement to the specs—not tribal knowledge that disappears when I leave. Here's what happened.

          section#what-is-spec-kit.mb-5
            h2.h3.mb-4
              i.bi.bi-info-circle.me-2
              | What Is Spec Kit?

            p.mb-3.
              GitHub Spec Kit is a framework that creates markdown artifacts during development: SPEC.md for requirements, PLAN.md for technical approach, TASKS.md for implementation steps. You use slash commands in Copilot (<code>/speckit.specify</code>, <code>/speckit.plan</code>, etc.) to generate these files.

            p.mb-0.
              The pitch: When implementation inevitably deviates from the plan, you tell the AI to update the specs. Instead of specs rotting immediately, they evolve to match reality. That's the theory. I tested it on a real project to see if it actually works.



          section#my-experiment.mb-5
            h2.h3.mb-4
              i.bi.bi-diagram-3.me-2
              | My Experiment: Two Real Specs

            p.mb-3.
              I picked WebSpark.HttpClientUtility, a production .NET NuGet package I maintain. Two features I'd been postponing: a documentation website and cleaning up compiler warnings. Perfect test cases—one creative, one tedious.

            p.mb-3.
              <strong>Spec 001: Build a documentation site.</strong> AI generated an Eleventy-based static site with 6 pages, NuGet API integration, and GitHub Pages deployment. It looked great. Then it broke in production because of path resolution issues.

            p.mb-0.
              <strong>Spec 002: Zero compiler warnings.</strong> Started with an unknown number of warnings. Goal: 0 warnings with TreatWarningsAsErrors enforced. AI tried to use <code>#pragma warning disable</code> suppressions. I rejected that and made it fix things properly with XML docs and null guards.
            p.mb-0.
              Those experiments taught me the fundamentals. But the real test came later with a Sunday morning thought experiment that turned into a complete production system in just half a day.

          section#github-stats-spark.mb-5
            h2.h3.mb-4
              i.bi.bi-stars.me-2
              | Deep Dive: Creating GitHub Stats Spark

            p.lead.mb-4.
              Stats Spark started as a deceptively simple idea—"illuminate my GitHub profile with automated SVG stats"—and grew into a rigorously planned system that blends GitHub SpecKit, Claude-powered planning, and GitHub Copilot-assisted iteration. Here's how a Sunday morning thought experiment became a production-ready automation pipeline in just half a day.

            h3.h5.mb-3 The Starting Point: A Simple Idea

            p.mb-3.
              I wanted automated SVG badges for my GitHub profile showing activity stats, contribution patterns, and a custom "Spark Score" that reflected consistency, volume, and collaboration. The goal wasn't just pretty graphics—I wanted a system that could regenerate stats daily and capture my development patterns over time.

            p.mb-0.
              Instead of jumping into code, I started with SpecKit. That decision shaped everything that followed.

            h3.h5.mb-3 Phase 1: Spec-First North Star

            .card.mb-4
              .card-header.bg-light
                h6.card-title.mb-0
                  i.bi.bi-file-text.me-2
                  | The Foundation: SPEC.md
              .card-body
                p.mb-3.
                  The spec captured everything: 6 user stories, 28 functional requirements (FR-001 through FR-028), measurable success criteria, and edge cases. Most importantly, it codified the Spark Score formula itself:

                pre.bg-dark.text-light.p-3.rounded.mb-3
                  code.text-light.
                    SparkScore = 0.40 × C_consistency + 0.35 × C_volume + 0.25 × C_collaboration

                p.mb-3.
                  This mathematical definition in the spec meant every downstream artifact—plan, tasks, implementation—inherited the same weighting. No ambiguity about priorities.

                .alert.alert-info.mb-0
                  p.mb-2.
                    <strong>What the spec defined:</strong>
                  ul.mb-0.small
                    li Six visualizations: activity calendar, language breakdown, repository stats, contribution timeline, collaboration network, streak tracker
                    li Scoring algorithm with explicit coefficients for consistency (40%), volume (35%), collaboration (25%)
                    li Success metrics: 6 SVG files, daily refresh, < 30s generation time
                    li Edge cases: API rate limits, timezone handling, private repo filtering
                    li Quality gates: YAML config validation, GitHub Actions integration

            h3.h5.mb-3 Phase 2: Claude + SpecKit Blueprint

            p.mb-3.
              After the spec, I ran <code>/speckit.plan</code> which generated PLAN.md—a complete architectural blueprint that read like a Claude playbook. This wasn't generic boilerplate; it was a detailed technical roadmap.

            .card.mb-4
              .card-header.bg-light
                h6.card-title.mb-0
                  i.bi.bi-diagram-3.me-2
                  | PLAN.md: The Connective Tissue
              .card-body
                p.mb-3.
                  PLAN.md bridged vision and implementation with:

                ul.mb-3
                  li
                    strong Constitution checks:
                    |  Design principles that would govern all decisions
                  li
                    strong Phase gates:
                    |  Four phases (Setup, Core, Integration, Polish) with clear dependencies
                  li
                    strong Technology bets:
                    |  PyGithub for API access, svgwrite for graphics, YAML for config, GitHub Actions for automation
                  li
                    strong Module contracts:
                    |  Named every module (GitHubFetcher, StatsCalculator, StatisticsVisualizer) with input/output specifications
                  li
                    strong Dependency graph:
                    |  Explicit call-outs of what depends on what, enabling parallel development

                p.mb-0.small.text-muted.
                  This level of detail is what makes the difference. It's not a vague "use Python and GitHub API"—it's "here's exactly how the pieces fit together and why we chose each technology."

            h3.h5.mb-3 Phase 3: Actionable Backlog

            p.mb-3.
              <code>/speckit.tasks</code> generated TASKS.md—127 traceable tasks with user story tags (US1–US6), parallelization hints, and checkpoints. This is where the spec becomes executable.

            .row.g-3.mb-4
              .col-md-6
                .card.border.h-100
                  .card-header.bg-light
                    h6.card-title.mb-0
                      i.bi.bi-list-check.me-2
                      | Task Breakdown Pattern
                  .card-body
                    pre.bg-dark.text-light.p-3.rounded.mb-0.small
                      code.text-light.
                        [US1] Daily Stats Update
                        ├─ Task 001: Setup GitHub Actions workflow
                        ├─ Task 002: Configure cron schedule  
                        ├─ Task 003: Implement stats fetcher
                        ├─ Task 004: Generate SVG outputs
                        └─ Task 005: Commit artifacts back to repo

              .col-md-6
                .card.border.h-100
                  .card-header.bg-light
                    h6.card-title.mb-0
                      i.bi.bi-shield-check.me-2
                      | Quality Gates
                  .card-body
                    ul.mb-0.small
                      li YAML config passes validation
                      li All SVGs render without errors
                      li GitHub Actions workflow succeeds
                      li Generation completes in < 30 seconds
                      li Artifacts committed to correct paths

            p.mb-0.
              Pairing PLAN.md with TASKS.md creates the "spec before code" discipline. You can't implement what you haven't defined, and you can't define it without thinking through dependencies.

            h3.h5.mb-3 Phase 4: The Claude-to-Copilot Handoff

            p.mb-3.
              The git commit history tells the implementation story. It shows three distinct phases that perfectly illustrate how SpecKit, Claude, and Copilot work together:

            .card.mb-4
              .card-header.bg-light
                h6.card-title.mb-0
                  i.bi.bi-git.me-2
                  | Git History as Build Log
              .card-body
                p.mb-3.
                  <strong>Phase 1: Specification Capture</strong>

                ul.mb-3.small
                  li Commit 73e83d2: Specification remediation—tightened requirements, added edge cases
                  li Commit 76d2ead: Implemented SpecKit command suite—committed generated SPEC.md, PLAN.md, TASKS.md

                p.mb-3.
                  <strong>Phase 2: Claude-Powered Scaffolding</strong>

                ul.mb-3.small
                  li Commit ceb52c5: Core modules landed—GitHubFetcher, StatsCalculator, StatisticsVisualizer
                  li Commit 282b378: Logging framework with structured output
                  li Commit 107985e: Theme system for visual consistency

                p.mb-3.
                  <strong>Phase 3: Copilot-Assisted Refinement</strong>

                ul.mb-0.small
                  li Commit e9e55ae: Fixed SVG spacing in commit heatmap
                  li Commit 1328888: Adjusted fun-stat layouts for mobile
                  li Commit ddf2df9: Tweaked coefficient-of-variation for consistency scoring
                  li Commit 2e28b21: Added release-cadence visualization

            p.mb-3.
              The pattern is clear: Claude owns the architecture and module scaffolding (the "what" and "how"), while Copilot handles surgical refinements (the "tweak" and "polish"). Heavy lifting up front, iteration at the edges.

            p.mb-0.
              This is exactly what the repo documents: SpecKit/Claude for structure, Copilot to sand the edges.

            h3.h5.mb-3 Phase 5: Automation Feedback Loop

            p.mb-3.
              The system wasn't done until it was self-sustaining. User Story 1 required daily automated updates, which meant GitHub Actions had to regenerate SVGs and commit them back to the repo.

            .card.mb-4
              .card-header.bg-light
                h6.card-title.mb-0
                  i.bi.bi-arrow-repeat.me-2
                  | Closed-Loop Automation
              .card-body
                p.mb-3.
                  Every manual push triggered <code>github-actions[bot]</code> commits that ran the scheduled workflow:

                ul.mb-3.small
                  li Commit b927634: Bot regenerated all SVGs after manual update
                  li Commit 3ad76d2: Daily scheduled run at 09:00 UTC
                  li Commit 88ae324: Artifacts committed back to repo automatically

                p.mb-0.
                  This proves the daily-job requirement from the spec was wired before feature development finished. The automation wasn't bolted on at the end—it was part of the architecture from PLAN.md forward.

            h3.h5.mb-3 What Made This Work: The Three-Tool Symphony

            .row.g-3.mb-4
              .col-lg-4
                .card.border-primary.h-100
                  .card-header.bg-primary.text-white
                    h6.card-title.mb-0
                      i.bi.bi-file-earmark-text.me-2
                      | SpecKit
                  .card-body
                    p.small.mb-2.
                      <strong>Role:</strong> Capture requirements, define success
                    p.small.mb-2.
                      <strong>Artifacts:</strong> SPEC.md, PLAN.md, TASKS.md
                    p.small.mb-0.
                      <strong>Value:</strong> Forces precision before coding, creates institutional knowledge

              .col-lg-4
                .card.border-success.h-100
                  .card-header.bg-success.text-white
                    h6.card-title.mb-0
                      i.bi.bi-lightning.me-2
                      | Claude
                  .card-body
                    p.small.mb-2.
                      <strong>Role:</strong> Architectural scaffolding, module design
                    p.small.mb-2.
                      <strong>Artifacts:</strong> Core classes, logging, themes
                    p.small.mb-0.
                      <strong>Value:</strong> Handles complexity, reads specs, owns the "how"

              .col-lg-4
                .card.border-info.h-100
                  .card-header.bg-info.text-white
                    h6.card-title.mb-0
                      i.bi.bi-stars.me-2
                      | Copilot
                  .card-body
                    p.small.mb-2.
                      <strong>Role:</strong> Iterative refinement, visual polish
                    p.small.mb-2.
                      <strong>Artifacts:</strong> Layout tweaks, spacing fixes, edge cases
                    p.small.mb-0.
                      <strong>Value:</strong> Rapid iteration, sands rough edges

            h3.h5.mb-3 The Half-Day Result

            .alert.alert-success.mb-4
              h6.alert-heading.mb-2
                i.bi.bi-check-circle-fill.me-2
                | What Got Built in Half a Day
              ul.mb-0
                li Six SVG visualizations (activity calendar, language breakdown, repo stats, timeline, collaboration, streaks)
                li Spark Score calculation with documented coefficients
                li GitHub Actions workflow with daily regeneration
                li YAML configuration system with validation
                li Complete logging and error handling
                li Theme system for visual consistency
                li Automated artifact commits back to repository

            .card.mb-4
              .card-header.bg-light
                h6.card-title.mb-0
                  i.bi.bi-eye.me-2
                  | Live Example: GitHub Stats Overview
              .card-body
                p.mb-3.
                  Here's what the system generates automatically. This SVG updates daily via GitHub Actions, showing real-time stats from my GitHub profile:

                .text-center.mb-3
                  img.img-fluid.rounded.border(src='https://raw.githubusercontent.com/markhazleton/github-stats-spark/main/output/overview.svg' alt='GitHub Stats Spark Overview' loading='lazy')

                p.mb-0.small.text-muted.
                  View the <a href="https://github.com/markhazleton" target="_blank" rel="noopener">complete GitHub profile</a> or explore the <a href="https://github.com/markhazleton/github-stats-spark" target="_blank" rel="noopener">Stats Spark repository</a> to see all visualizations and implementation details.

            p.mb-3.
              More importantly: every architectural decision, every algorithm choice, every "why we did it this way" is captured in the SpecKit artifacts. The repository documents its own creation.

            h3.h5.mb-3 The Living Documentation Payoff

            p.mb-3.
              Here's where it matters: if I need to extend Stats Spark in six months, or if someone else picks it up, the specs tell the whole story. Why those specific coefficient weights? It's in SPEC.md with the research citations. Why svgwrite instead of PIL for graphics? PLAN.md explains the decision criteria. What order should features be implemented? TASKS.md has the dependency graph.

            p.mb-0.
              That's institutional knowledge, not tribal knowledge. And it took an extra 30 minutes to update the specs after implementation—capturing what worked, what didn't, and why the final solution differs from the initial plan.
          section#what-i-learned.mb-5
            h2.h3.mb-4
              i.bi.bi-lightbulb.me-2
              | What I Learned Writing the Specs

            p.mb-3.
              The specs forced me to think more precisely than I usually do. For the warning cleanup, I had to define "done" upfront: zero warnings, TreatWarningsAsErrors enabled, 520 tests still passing, no pragma suppressions allowed.

            .alert.alert-warning.mb-4
              h6.alert-heading.mb-2
                i.bi.bi-exclamation-triangle.me-2
                | Mistakes I Made
              ul.mb-0
                li
                  strong Too vague on baseline:
                  |  I said "unknown number of warnings" instead of auditing first. AI wasted time figuring out what to fix.
                li
                  strong Missing priority order:
                  |  AI tried to fix everything simultaneously. Should have said: "Fix XML docs first, then null safety, then analyzers."
                li
                  strong No time estimate:
                  |  Without "Target: 4 hours" I lost focus during implementation.

            p.mb-0.
              Here's what surprised me: these mistakes became permanent improvements to the specs. After implementation, I spent 20 minutes having AI update SPEC.md to reflect what actually worked. Future features inherit those lessons.

          section#feedback-examples.mb-5
            h2.h3.mb-4
              i.bi.bi-arrow-repeat.me-2
              | The Feedback Loop in Practice

            p.mb-3.
              Each time AI generated wrong code, I fixed it and had AI update the specs. Here's why that matters: these lessons are now permanent documentation that future developers (and AI agents) will read before making changes.

            h3.h5.mb-3 Three Implementation Lessons That Became Institutional Knowledge

            .card.mb-3
              .card-header.bg-light
                h6.card-title.mb-0
                  i.bi.bi-1-circle.me-2
                  | Path Resolution: Spec Said One Thing, Reality Required Another
              .card-body
                ul.list-unstyled.mb-0
                  li
                    strong AI generated:
                    |  Absolute paths using pathPrefix config (standard Eleventy approach)
                  li
                    strong What broke:
                    |  GitHub Pages subdirectory deployment
                  li
                    strong I fixed it:
                    |  Custom <code>relativePath</code> filter that calculates paths dynamically
                  li
                    strong Then I closed the loop:
                    |  "Update SPEC.md and PLAN.md to document why pathPrefix failed and what works instead"
                  li.mt-2
                    strong Result:
                    |  SPEC.md now says "No environment-specific configuration." PLAN.md shows pathPrefix crossed out with the working alternative. Next developer won't try pathPrefix because the spec explains why it doesn't work.

            .card.mb-3
              .card-header.bg-light
                h6.card-title.mb-0
                  i.bi.bi-2-circle.me-2
                  | Warning Suppression: Spec Was Too Vague
              .card-body
                ul.list-unstyled.mb-0
                  li
                    strong AI generated:
                    |  <code>#pragma warning disable</code> directives (fastest solution)
                  li
                    strong Spec said:
                    |  "No suppressions" but didn't say HOW to fix properly
                  li
                    strong I fixed it:
                    |  200+ XML docs, null guards with <code>ArgumentNullException.ThrowIfNull()</code>
                  li
                    strong Then I closed the loop:
                    |  "Update SPEC.md with specific examples of acceptable vs. unacceptable fixes"
                  li.mt-2
                    strong Result:
                    |  SPEC.md now has a "✅ DO / ❌ DON'T" section. PLAN.md has a 5-step remediation strategy. TASKS.md breaks it into auditable chunks. Future features inherit this standard.

            .card.mb-3
              .card-header.bg-light
                h6.card-title.mb-0
                  i.bi.bi-3-circle.me-2
                  | Test Documentation: Spec Didn't Ask, AI Didn't Deliver
              .card-body
                ul.list-unstyled.mb-0
                  li
                    strong AI generated:
                    |  Documented library code, skipped test methods entirely
                  li
                    strong Spec said:
                    |  "520 tests passing" but not "tests need documentation"
                  li
                    strong I fixed it:
                    |  Added XML docs to 260 test methods explaining WHAT and WHY
                  li
                    strong Then I closed the loop:
                    |  "Update SPEC.md to require test documentation. Add principle to CONSTITUTION.md: 'Tests are product documentation.'"
                  li.mt-2
                    strong Result:
                    |  Every future spec inherits "tests need docs" standard. AI reads the constitution before generating code. The team's quality bar persists beyond individual developers.

            h3.h5.mb-3 Why This Solves a 40-Year-Old Problem

            p.mb-0.
              In waterfall, specs froze at design and diverged immediately. In agile, we stopped writing specs because maintaining them was humanly impossible. GitHub Spec Kit closes the loop: when implementation teaches you something, you spend 20 minutes having AI update the specs. The path resolution lesson, the warning fix patterns, the test documentation standard—all permanent institutional knowledge that AI agents read before generating the next feature. That's what survives team turnover.

          section#faq.mb-5
            h2.h3.mb-4
              i.bi.bi-question-circle.me-2
              | Frequently Asked Questions

            .accordion#faqAccordion
              .accordion-item
                h3.accordion-header#faq1
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapse1'
                    aria-expanded='false'
                    aria-controls='collapse1'
                    aria-label='Does this only work with GitHub Copilot?'
                  )
                    i.bi.bi-question-circle-fill.me-2
                    | Does this only work with GitHub Copilot?
                .accordion-collapse.collapse#collapse1(
                  aria-labelledby='faq1'
                  data-bs-parent='#faqAccordion'
                )
                  .accordion-body.
                    No. The pattern is model-agnostic. Any LLM benefits from structured specs and tests.

              .accordion-item
                h3.accordion-header#faq2
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapse2'
                    aria-expanded='false'
                    aria-controls='collapse2'
                    aria-label='Is this just test-driven development?'
                  )
                    i.bi.bi-question-circle-fill.me-2
                    | Isn't this just test-driven development?
                .accordion-collapse.collapse#collapse2(
                  aria-labelledby='faq2'
                  data-bs-parent='#faqAccordion'
                )
                  .accordion-body.
                    It's complementary. Spec Kit codifies requirements and examples up front, then TDD validates them. The twist is that you're writing for humans and an AI partner simultaneously.

              .accordion-item
                h3.accordion-header#faq3
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapse3'
                    aria-expanded='false'
                    aria-controls='collapse3'
                    aria-label='What if my problem is too open-ended for a spec?'
                  )
                    i.bi.bi-question-circle-fill.me-2
                    | What if my problem is too open-ended for a spec?
                .accordion-collapse.collapse#collapse3(
                  aria-labelledby='faq3'
                  data-bs-parent='#faqAccordion'
                )
                  .accordion-body.
                    Break it into spec-able slices. Use research spikes to learn, then spec the actionable parts.

              .accordion-item
                h3.accordion-header#faq4
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapse4'
                    aria-expanded='false'
                    aria-controls='collapse4'
                    aria-label='What if Copilot still gets it wrong?'
                  )
                    i.bi.bi-question-circle-fill.me-2
                    | What if Copilot still gets it wrong?
                .accordion-collapse.collapse#collapse4(
                  aria-labelledby='faq4'
                  data-bs-parent='#faqAccordion'
                )
                  .accordion-body.
                    Tighten the spec, add failing tests for the misbehavior, and iterate. Avoid changing code and spec in opposite directions.

          section#the-awkward-part.mb-5
            h2.h3.mb-4
              i.bi.bi-arrow-repeat.me-2
              | The Awkward Part: Updating Specs After Implementation

            h3.h5.mb-3 The Critical Step Everyone Skips

            p.mb-3.
              Here's the reality: after <code>/speckit.implement</code> completes, you'll tweak edge cases, adjust UX, and fix bugs the AI missed. This iteration is expected and normal. What's different is what you do next.

            .alert.alert-warning.mb-4
              h6.alert-heading.mb-2
                i.bi.bi-exclamation-triangle-fill.me-2
                | THIS is Where the Value Lives
              p.mb-2.
                When you finally get it right, <strong>tell the agent to update SPEC.md, PLAN.md, and TASKS.md</strong> to reflect what you actually built. This 20-minute step is what traditional approaches skip—and why documentation always becomes outdated.
              p.mb-0.small.
                Example: "I fixed the GitHub Pages path resolution by implementing a custom relativePath filter. Please update SPEC.md and PLAN.md to reflect this solution instead of the original pathPrefix approach, and explain why pathPrefix failed."

            .row.g-3.mb-4
              .col-lg-6
                .card.border-danger.h-100
                  .card-header.bg-light
                    h6.card-title.mb-0
                      i.bi.bi-x-circle.me-2.text-danger
                      | Without Feedback Loop
                  .card-body
                    ul.mb-0.small
                      li Specs describe what you planned, not what you built
                      li Future developers follow outdated documentation
                      li Institutional knowledge lives only in your head
                      li Next feature repeats the same mistakes

              .col-lg-6
                .card.border-success.h-100
                  .card-header.bg-light
                    h6.card-title.mb-0
                      i.bi.bi-check-circle.me-2.text-success
                      | With Feedback Loop
                  .card-body
                    ul.mb-0.small
                      li Specs evolve to match reality (living documentation)
                      li Future developers see what actually works
                      li Team learns from real-world implementation
                      li Each spec becomes more accurate over time

            p.mb-0.
              The feedback loop keeps specs synchronized with reality. Your specs document what you built and what you learned—useful for your future self and your team.

          section#conclusion.mb-5
            h2.h3.mb-4
              i.bi.bi-trophy.me-2
              | Should You Try It?

            p.lead.mb-4.
              Spec Kit won't make you ship faster initially. What it does: gives you documentation that still matches reality three months later. That's worth something if you maintain long-lived codebases or work on teams where knowledge walks out the door.

            h3.h5.mb-3 Try it if:

            ul.mb-4
              li You maintain libraries or APIs where documentation debt is expensive
              li You work on teams where "ask Bob" isn't a sustainable knowledge strategy
              li You inherit codebases and wish the previous developer had explained their decisions
              li You're building something that will outlive your involvement

            h3.h5.mb-3 Skip it if:

            ul.mb-4
              li You're prototyping and will throw away the code
              li You're solo and have no knowledge transfer problem
              li You're exploring and don't know what you're building yet
              li You're fixing a production fire and documentation can wait

            .alert.alert-success.mb-4
              h6.alert-heading.mb-2
                i.bi.bi-check-circle-fill.me-2
                | What This Project Delivered: Persistent Knowledge
              ul.mb-0
                li
                  strong Path resolution pattern:
                  |  Custom relativePath filter documented in specs—future developers won't repeat the pathPrefix mistake
                li
                  strong Warning remediation strategy:
                  |  XML docs + ArgumentNullException.ThrowIfNull() pattern captured in PLAN.md—team inherits the standard
                li
                  strong Test documentation philosophy:
                  |  "Tests are product documentation" principle added to CONSTITUTION.md—applies to all future features
                li
                  strong Specs that match reality:
                  |  Documentation updated after implementation reflects what actually works, not what was initially planned
                li
                  strong Zero documentation debt:
                  |  20 minutes to sync specs vs. never updating them = institutional knowledge that survives team turnover

            p.mb-0.
              My verdict: Spec Kit solved a problem I've had for 20 years—documentation that matches reality months later. The trade-off is 20 minutes per feature updating specs after you fix what AI got wrong. If you maintain code beyond the initial sprint, that's a bargain.

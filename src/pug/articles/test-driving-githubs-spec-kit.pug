extends ../layouts/modern-layout

//- Import standardized article mixins
include ../modules/article-mixins

block layout-content
  br
  // Hero Section
  section.bg-gradient-primary.py-5
    .container
      .row.align-items-center
        .col-lg-10.mx-auto.text-center
          h1.display-4.fw-bold.mb-3
            i.bi.bi-lightbulb.me-3
            | GitHub Spec Kit
          h2.mb-4 Test Driving GitHub Spec Kit: From Three-Ring Binders to Living Documentation

  //- Main Article Content
  article#main-article
    .container
      .row
        .col-lg-8.mx-auto

          p.lead.mb-4.text-center.mt-4.
            Using structured specifications to guide AI code generation with measurable results.

          //- Table of contents
          +tableOfContents([
            { href: '#executive-summary', text: 'Executive Summary' },
            { href: '#documentation-drift', text: 'The Documentation Drift Problem' },
            { href: '#what-is-spec-kit', text: 'What Is GitHub Spec Kit?' },
            { href: '#feedback-loop', text: 'The Post-Implementation Feedback Loop' },
            { href: '#case-study', text: 'Case Study: WebSpark.HttpClientUtility' },
            { href: '#results', text: 'Results: Zero Documentation Debt' },
            { href: '#workflow', text: 'Following the Spec Kit Flow' },
            { href: '#conclusion', text: 'When to Use Spec Kit' }
          ])

          section#executive-summary.mb-5
            h2.h3.mb-4
              i.bi.bi-file-earmark-text.me-2
              | Executive Summary

            p.lead.mb-4.
              Every developer knows the pattern: Design document says one thing, code does another, six months later nobody knows which is correct. Waterfall specs died when code changed. Agile threw out specs entirely. Both failed for the same reason—humans won't maintain documentation when it's divorced from implementation.

            p.mb-4.
              GitHub Spec Kit closes the feedback loop: AI agents update documentation when implementation diverges, so specs become living artifacts instead of shelf-ware. The ROI isn't faster development—it's specs that still accurately describe the codebase three months later.

            .card.mb-4
              .card-header.bg-light
                h5.card-title.mb-0
                  i.bi.bi-trophy.me-2
                  | What You'll Learn
              .card-body
                ul.mb-0
                  li
                    strong Solving documentation drift:
                    |  How AI agents close the feedback loop humans never could—specs stay synchronized with implementation
                  li
                    strong Institutional knowledge persistence:
                    |  Path resolution patterns, warning remediation strategies, architectural decisions captured in markdown that survives team turnover
                  li
                    strong The feedback cycle:
                    |  AI generates → human fixes → human tells AI to update specs → knowledge persists forever
                  li
                    strong When it matters:
                    |  Libraries, APIs, multi-year projects where tribal knowledge creates single points of failure
                  li
                    strong Real metrics:
                    |  Implementation: 7 hours (same as always). Documentation sync: 20 minutes (vs. never). Result: Zero documentation debt.

            .card.mb-4
              .card-header.bg-light
                h5.card-title.mb-0
                  i.bi.bi-people.me-2
                  | Who This Is For
              .card-body
                ul.mb-0
                  li
                    strong Solutions Architects:
                    |  Translate business requirements into technology with precision
                  li
                    strong Development Teams:
                    |  Escape the prompt-generate-debug cycle with structured workflows
                  li
                    strong Engineering Leaders:
                    |  Build institutional knowledge that scales beyond individual contributors
                  li
                    strong .NET Developers:
                    |  Practical patterns for NuGet packages, documentation, and quality enforcement

            .alert.alert-info.mb-0
              h6.alert-heading
                i.bi.bi-link-45deg.me-2
                | References
              ul.mb-0
                li
                  | GitHub Spec Kit: 
                  a(href='https://github.com/github/spec-kit', target='_blank', rel='noopener') https://github.com/github/spec-kit
                li
                  | GitHub Copilot: 
                  a(href='https://github.com/features/copilot', target='_blank', rel='noopener') https://github.com/features/copilot
                li
                  | WebSpark.HttpClientUtility Repository: 
                  a(href='https://github.com/markhazleton/WebSpark.HttpClientUtility', target='_blank', rel='noopener') Real-world example project
                li
                  | GitHub Actions: 
                  a(href='https://docs.github.com/actions', target='_blank', rel='noopener') https://docs.github.com/actions
                li
                  | NuGet Publishing: 
                  a(href='https://learn.microsoft.com/nuget/create-packages/publish-a-package', target='_blank', rel='noopener') https://learn.microsoft.com/nuget/create-packages/publish-a-package

          section#documentation-drift.mb-5
            h2.h3.mb-4
              i.bi.bi-arrow-right-circle.me-2
              | The Documentation Drift Problem

            p.mb-3.
              Every codebase has specs that lie. They said one thing at design time, developers changed it during implementation, and nobody updated the docs. Waterfall tried to solve this with upfront perfection—specs froze before coding started. Agile gave up entirely—"working software over comprehensive documentation."

            p.mb-3.
              Both failed for the same reason: humans won't maintain documentation when it's divorced from implementation. The feedback loop is too expensive.

            p.mb-3.
              I spent 8 years at EDS maintaining three-ring binders of waterfall specs. The specs were beautiful at handoff. Three months later, they were fiction. The human cost of keeping specs synchronized with code was unsustainable.

            h3.h5.mb-3 What If AI Could Close the Loop?

            p.mb-3.
              GitHub Spec Kit offers something different: AI agents that update documentation when implementation changes.

            p.mb-3.
              The cycle: AI generates code from spec → human fixes what's wrong → human tells AI "update the specs to match reality" → specs evolve instead of ossifying.

            p.mb-0.
              I tested this on a production NuGet package. Two features, 7 hours of work, 136 files changed. Every deviation from the original plan became a permanent improvement to the specs—not tribal knowledge that disappears when I leave. Here's what happened.

          section#what-is-spec-kit.mb-5
            h2.h3.mb-4
              i.bi.bi-info-circle.me-2
              | What Is GitHub Spec Kit?

            p.mb-3.
              GitHub Spec Kit structures AI development into phases that generate persistent documentation. Instead of prompting until code works, you run commands that create markdown artifacts: <code>/speckit.specify</code> captures requirements in SPEC.md, <code>/speckit.plan</code> determines technical approach in PLAN.md, <code>/speckit.tasks</code> breaks work into TASKS.md, and <code>/speckit.implement</code> generates code.

            p.mb-3.
              These files live alongside your code in <code>specifications/001-feature-name/</code>. The structure forces you to think before coding—but more importantly, the files become living documentation. When implementation deviates from the plan (and it always does), you tell the AI to update the specs to match reality.

            p.mb-3.
              A <code>/speckit.constitution</code> file defines project-wide standards once, guiding all generation. Optional commands like <code>/speckit.clarify</code> catch ambiguities before implementation. The full toolkit is open-source (MIT) at <a href="https://github.com/github/spec-kit" target="_blank" rel="noopener">github/spec-kit</a>.

          section#feedback-loop.mb-5
            h2.h3.mb-4
              i.bi.bi-arrow-repeat.me-2
              | The Post-Implementation Feedback Loop: The Core Innovation

            p.mb-3.
              Here's what makes GitHub Spec Kit fundamentally different from traditional documentation: it's designed for AI agents to update specs when implementation diverges from the plan. This isn't about generating code faster—it's about maintaining knowledge that survives team turnover.

            .row.g-3.mb-4
              .col-md-6
                .card.border-secondary.h-100
                  .card-header.bg-light
                    h6.card-title.mb-0
                      i.bi.bi-x-circle.me-2.text-danger
                      | Traditional Approach
                  .card-body.small
                    ol.mb-0
                      li Write specs during planning phase
                      li Implement feature with inevitable deviations
                      li Ship code without updating specs
                      li Six months later: specs are fiction
                      li New developer wastes hours reconciling

              .col-md-6
                .card.border-success.h-100
                  .card-header.bg-light
                    h6.card-title.mb-0
                      i.bi.bi-check-circle.me-2.text-success
                      | GitHub Spec Kit Cycle
                  .card-body.small
                    ol.mb-0
                      li AI generates code from SPEC.md
                      li Human fixes what doesn't work
                      li Human tells AI: "Update specs to match reality"
                      li Specs evolve to document what actually works
                      li Knowledge persists in repository

            h3.h5.mb-3 Why This Matters: Path Resolution Example

            p.mb-3.
              AI generated code using pathPrefix configuration (standard Eleventy approach). It failed in GitHub Pages subdirectory deployment. I fixed it with a custom relativePath filter. Then I spent 20 minutes having AI update SPEC.md and PLAN.md to document why pathPrefix failed and what works instead.

            p.mb-3.
              Result: Next developer doesn't try pathPrefix because the spec explains the failure. That's institutional knowledge that survives my departure—not tribal knowledge that walks out the door.

            p.mb-0.
              Now let's see this pattern applied to a real production project.

          section#case-study.mb-5
            h2.h3.mb-4
              i.bi.bi-diagram-3.me-2
              | Case Study: WebSpark.HttpClientUtility — A Production .NET NuGet Package

            p.mb-3.
              I applied Spec Kit to WebSpark.HttpClientUtility, a .NET 8/9 NuGet package with decorator-pattern HTTP client utilities. Results from two specs:

            .row.g-3.mb-4
              .col-md-6
                .card.h-100.border-primary
                  .card-header.bg-primary.text-white
                    h5.card-title.mb-0
                      i.bi.bi-file-text.me-2
                      | Spec 001: Static Documentation Site
                  .card-body
                    p Built complete Eleventy-based documentation website
                    ul.small.mb-0
                      li 6 pages with responsive design
                      li Live NuGet API integration
                      li GitHub Pages deployment
                      li Build time: 0.4 seconds

              .col-md-6
                .card.h-100.border-success
                  .card-header.bg-success.text-white
                    h5.card-title.mb-0
                      i.bi.bi-check-circle.me-2
                      | Spec 002: Zero Compiler Warnings
                  .card-body
                    p Achieved professional quality baseline
                    ul.small.mb-0
                      li 0 warnings, 0 errors
                      li 520/520 tests passing
                      li TreatWarningsAsErrors enabled
                      li XML docs for all public APIs

            p.mb-0.
              I'll walk through both specs, showing how Spec Kit moved me from ambiguous goals to shipped releases (v1.5.0 and v1.5.1).

          section#repository-layout.mb-5
            h2.h3.mb-4
              i.bi.bi-folder.me-2
              | Repository Layout

            p.mb-3.
              Here's the repository structure that emerged from the spec-driven process. Note the distinction between <code>.specify/</code> (Spec Kit framework and templates) and <code>specifications/</code> (your actual project specs). Each spec directory contains the complete spec-plan-tasks workflow artifacts:

            .alert.alert-info.mb-3
              h6.alert-heading.mb-2
                i.bi.bi-info-circle.me-2
                | Understanding the Structure
              ul.mb-0.small
                li
                  strong .specify/:
                  |  Framework files (constitution, templates, scripts)
                li
                  strong specifications/:
                  |  Your actual project specs with full workflow artifacts
                li
                  strong Why 1,648 lines of tasks.md?
                  |  Documentation site spec broke down into granular, testable tasks across HTML, CSS, JS, CI/CD
                li
                  strong copilot-instructions.md (244 lines):
                  |  Project-specific AI guidance including coding standards, architecture decisions, and common patterns

            pre.language-plaintext.bg-dark.text-light.p-3.rounded
              code.language-plaintext.text-light.
                WebSpark.HttpClientUtility/
                ├─ .specify/                      # Spec Kit framework
                │  ├─ memory/constitution.md      # Project principles
                │  ├─ templates/                  # Spec templates
                │  └─ scripts/                    # Automation scripts
                ├─ specifications/
                │  ├─ 001-static-documentation-site/
                │  │  ├─ spec.md                  # 724 lines
                │  │  ├─ plan.md                  # 835 lines
                │  │  ├─ tasks.md                 # 1,648 lines
                │  │  └─ data-model.md
                │  └─ 002-clean-compiler-warnings/
                │     ├─ spec.md                  # 120 lines
                │     ├─ plan.md                  # 258 lines
                │     └─ tasks.md                 # 332 lines
                ├─ src/                           # Library source
                │  └─ WebSpark.HttpClientUtility/
                │     ├─ ClientService/
                │     ├─ Crawler/
                │     ├─ MemoryCache/
                │     └─ Streaming/
                ├─ test/                          # 520 tests (×2 frameworks)
                │  └─ WebSpark.HttpClientUtility.Test/
                ├─ docs/                          # Generated documentation
                │  ├─ index.html
                │  ├─ getting-started/
                │  ├─ api/
                │  └─ examples/
                ├─ .github/
                │  ├─ workflows/
                │  │  ├─ dotnet.yml              # CI/CD pipeline
                │  │  └─ publish-docs.yml        # Doc deployment
                │  └─ copilot-instructions.md    # 244 lines
                └─ Directory.Build.props         # Solution-wide config

          section#the-spec.mb-5
            h2.h3.mb-4
              i.bi.bi-file-text.me-2
              | The Spec: Spec 002 - Clean Compiler Warnings

            p.mb-3.
              Below is the actual spec that drove me from "unknown number of warnings" to zero warnings with enforcement enabled. It's intentionally explicit and measurable.

            pre.language-markdown.bg-dark.text-light.p-3.rounded
              code.language-markdown.text-light.
                # Spec 002: Clean Compiler Warnings

                ## Summary
                Achieve zero compiler warnings across all three projects in the WebSpark.HttpClientUtility solution and enable TreatWarningsAsErrors for CI/CD enforcement.

                Target frameworks: net8.0, net9.0
                Projects: Library, Test, Web App

                ## Goals
                - Zero compiler warnings in Release and Debug configurations
                - Enable TreatWarningsAsErrors solution-wide
                - Maintain 100% test pass rate (520 tests × 2 frameworks)
                - Comprehensive XML documentation for all public APIs
                - Professional quality baseline for NuGet package

                ## Non-Goals
                - Suppress warnings without fixing root causes
                - Compromise API design to avoid warnings
                - Skip test documentation (treat tests as product)
                - Delay enforcement—enable immediately after cleanup

                ## Constraints
                - Cannot break existing public API contracts
                - Cannot reduce test coverage
                - Must target both net8.0 and net9.0
                - Must pass all 520 existing tests
                - Changes must be backward compatible

                ## Current State Analysis Required
                1. Run `dotnet build -c Release -v detailed > build_warnings.txt`
                2. Categorize warnings by type (CS1591, CS8602, CA2007, etc.)
                3. Prioritize: Public API docs > Null safety > Code analysis
                4. Document baseline count per category

                ## Acceptance Criteria
                - `dotnet build` produces 0 warnings and 0 errors
                - All 520 tests pass on net8.0 and net9.0
                - `TreatWarningsAsErrors` enabled in Directory.Build.props
                - XML docs for all public classes, methods, properties
                - Null reference warnings resolved (not suppressed)
                - Code analysis rules properly configured in .editorconfig

                ## File Plan
                - src/WebSpark.HttpClientUtility/**/*.cs (add XML docs, null checks)
                - test/WebSpark.HttpClientUtility.Test/**/*.cs (document test intent)
                - Directory.Build.props (enable TreatWarningsAsErrors)
                - .editorconfig (configure analyzer severities)
                - Build verification scripts

                ## Done Definition
                - Build log shows "0 Warning(s)"
                - Test output shows "520 passed"
                - CI/CD pipeline passes with TreatWarningsAsErrors
                - No #pragma warning disable directives added
                - Documentation complete for all public surface area

            p.mb-3.
              Notice how the spec avoids prescribing HOW to fix warnings—it defines the target state and constraints, letting the implementer (human or AI) determine the optimal approach.

            .alert.alert-warning.mb-0
              h6.alert-heading.mb-2
                i.bi.bi-exclamation-triangle.me-2
                | What I Learned: Spec Weaknesses
              p.mb-2 This spec worked well, but I made mistakes that cost time:
              ul.mb-0
                li
                  strong Too vague on "unknown baseline":
                  |  Should have run the audit FIRST and documented exact warning counts by category
                li
                  strong Missing priority order:
                  |  AI tried to fix everything simultaneously. Should have specified: "Fix CS1591 docs first, then null safety, then code analysis"
                li
                  strong No time estimate:
                  |  Without "Target: 4 hours" in the spec, I lost focus during implementation
                li
                  strong Lesson:
                  |  Even good specs have gaps. The feedback loop caught these issues, and I updated the spec after implementation to reflect what actually worked.

          section#implementation.mb-5
            h2.h3.mb-4
              i.bi.bi-code-slash.me-2
              | Driving Implementation with the Spec

            p.mb-3.
              With SPEC.md in place, Copilot had a clear target and generated the implementation according to the spec's requirements. The actual code changes involved adding XML documentation, implementing null guards, and configuring analyzer rules.

            .alert.alert-info.mb-4
              h6.alert-heading.mb-2
                i.bi.bi-github.me-2
                | View Implementation Details
              p.mb-0
                | For complete before/after code changes, see the 
                a.text-decoration-none(href='https://github.com/markhazleton/WebSpark.HttpClientUtility' target='_blank' rel='noopener') WebSpark.HttpClientUtility repository
                |  and review the commit history for Spec 001 (documentation) and Spec 002 (zero warnings).

          section#tests.mb-5
            h2.h3.mb-4
              i.bi.bi-check2-square.me-2
              | Tests as Acceptance Criteria

            p.mb-3.
              Writing tests from the spec gave Copilot unambiguous targets. The existing 520-test suite (260 tests × 2 frameworks) served as acceptance criteria, ensuring no regressions while adding XML documentation and null guards.

            .alert.alert-success.mb-4
              h6.alert-heading.mb-2
                i.bi.bi-check-circle-fill.me-2
                | Test Coverage
              ul.mb-0
                li
                  strong 520 tests passing
                  |  (260 tests across .NET 8.0 and 9.0)
                li
                  strong Zero test failures
                  |  throughout implementation
                li
                  strong XML documentation tests
                  |  validate all public APIs documented
                li
                  strong Parameter validation tests
                  |  ensure ArgumentNullException coverage

            p.mb-0.
              The spec's constraint "Must pass all 520 existing tests" made the test suite non-negotiable, preventing shortcuts that might have broken existing functionality.

          section#packaging.mb-5
            h2.h3.mb-4
              i.bi.bi-box-seam.me-2
              | Packaging for NuGet

            p.mb-4.
              One of the most valuable outcomes of the Spec Kit approach was integrating CI/CD directly into the "Done Definition." GitHub Actions workflows became gatekeepers that validated every change before allowing new versions to ship.

            .row.g-3.mb-4
              .col-lg-6
                .card.border-primary.h-100
                  .card-header.bg-light
                    h5.card-title.mb-0
                      i.bi.bi-play-circle.me-2.text-primary
                      | CI Pipeline (Continuous Integration)
                  .card-body
                    p.mb-3 Runs on every push and pull request to validate code quality:
                    ul.mb-0
                      li
                        strong Restore dependencies
                        |  - Ensure all packages resolve correctly
                      li
                        strong Build solution
                        |  - Compile with TreatWarningsAsErrors enabled
                      li
                        strong Run 520 tests
                        |  - Execute full test suite across net8.0 and net9.0
                      li
                        strong Code coverage
                        |  - Track test coverage metrics
                      li
                        strong Fail fast
                        |  - Block PRs if any step fails

              .col-lg-6
                .card.border-success.h-100
                  .card-header.bg-light
                    h5.card-title.mb-0
                      i.bi.bi-box-seam.me-2.text-success
                      | Publish Pipeline (Release)
                  .card-body
                    p.mb-3 Triggered by version tags (e.g., v1.5.0) to deploy to NuGet.org:
                    ul.mb-0
                      li
                        strong Build Release configuration
                        |  - Full optimization enabled
                      li
                        strong Pack NuGet package
                        |  - Generate .nupkg with metadata
                      li
                        strong Run final tests
                        |  - Last validation before publish
                      li
                        strong Push to NuGet.org
                        |  - Automated deployment with API key
                      li
                        strong Skip duplicates
                        |  - Prevent accidental republish

            .alert.alert-info.mb-4
              h6.alert-heading.mb-2
                i.bi.bi-shield-check.me-2
                | Quality Gates in Action
              p.mb-2 The CI/CD pipeline enforces the spec's constraints automatically:
              ul.mb-0
                li
                  strong Zero warnings requirement
                  |  - Build fails if warnings appear (TreatWarningsAsErrors)
                li
                  strong Test coverage mandate
                  |  - 520 tests must pass before any merge
                li
                  strong API contract validation
                  |  - Tests prevent breaking changes
                li
                  strong Manual release control
                  |  - No NuGet publish without explicit version tag

            p.mb-0.
              This automation simplified the release process dramatically. Instead of manually running tests, checking warnings, packing, and publishing, a single 
              code git tag v1.5.1
              |  command triggers the entire validated pipeline. The GitHub Spec Kit "Done Definition" became executable infrastructure, not just documentation. For complete workflow details, see the 
              a.text-decoration-none(href='https://github.com/markhazleton/WebSpark.HttpClientUtility/tree/main/.github/workflows' target='_blank' rel='noopener') .github/workflows directory
              |  in the repository.

          section#results.mb-5
            h2.h3.mb-4
              i.bi.bi-graph-up.me-2
              | Results: Zero Documentation Debt

            p.mb-3.
              Over two specifications on WebSpark.HttpClientUtility, I achieved the real win: specs that still accurately describe the codebase three months later. Implementation took the same 7 hours it always does. Documentation sync took an additional 20 minutes. That 20 minutes is what traditional approaches skip—and why documentation always becomes outdated.

            .alert.alert-success.mb-4
              h5.alert-heading
                i.bi.bi-check-circle-fill.me-2
                | Quantitative Outcomes: What Actually Matters
              ul.mb-0
                li
                  strong 20 minutes to sync specs 
                  | (vs. never updating them in traditional approach = zero documentation debt)
                li
                  strong Path resolution pattern documented 
                  | (relativePath filter replaces pathPrefix—next developer won't repeat the mistake)
                li
                  strong Warning remediation strategy captured 
                  | (XML docs + ArgumentNullException.ThrowIfNull() pattern now team standard)
                li
                  strong Test documentation philosophy formalized 
                  | ("Tests are product documentation" principle added to constitution)
                li
                  strong 136 files changed 
                  | (29,141 insertions, 3,167 deletions across 2 production releases)
                li
                  strong 520/520 tests passing 
                  | (260 tests × 2 frameworks: net8.0 + net9.0 with zero regressions)

            h3.h6.mb-3 The Long-Term Value: What Happens After You Ship

            .table-responsive.mb-3
              table.table.table-bordered.table-striped(aria-label='Spec Kit vs Ad Hoc comparison')
                thead.table-light
                  tr
                    th Metric
                    th With Spec Kit
                    th Typical Ad Hoc
                    th Impact Over 12 Months
                tbody
                  tr
                    td Implementation time
                    td 7 hours
                    td 7 hours
                    td No difference initially
                  tr
                    td Documentation sync
                    td 20 minutes (AI-assisted)
                    td Never happens
                    td × Zero technical debt accumulation
                  tr
                    td Spec accuracy after 6 months
                    td Matches implementation
                    td Fiction
                    td × New developers trust docs
                  tr
                    td Knowledge persistence
                    td Survives team turnover
                    td Walks out the door
                    td × No single points of failure
                  tr
                    td Next feature cost
                    td AI reads accurate patterns
                    td Developer reinvents solutions
                    td × Compounds with each feature
                  tr
                    td Onboarding time
                    td Read specs that match code
                    td Reverse-engineer from codebase
                    td × 3 hours saved per developer

            p.mb-0.
              The spec-driven approach doesn't make you faster initially—it prevents knowledge decay. When you return to the codebase a year later, or when a new team member joins, the specs accurately describe what was built and why. That's institutional knowledge, not tribal knowledge.

          section#feedback-examples.mb-5
            h2.h3.mb-4
              i.bi.bi-arrow-repeat.me-2
              | The Feedback Loop in Practice

            p.mb-3.
              Each time AI generated wrong code, I fixed it and had AI update the specs. Here's why that matters: these lessons are now permanent documentation that future developers (and AI agents) will read before making changes.

            h3.h5.mb-3 Three Implementation Lessons That Became Institutional Knowledge

            .card.mb-3
              .card-header.bg-light
                h6.card-title.mb-0
                  i.bi.bi-1-circle.me-2
                  | Path Resolution: Spec Said One Thing, Reality Required Another
              .card-body
                ul.list-unstyled.mb-0
                  li
                    strong AI generated:
                    |  Absolute paths using pathPrefix config (standard Eleventy approach)
                  li
                    strong What broke:
                    |  GitHub Pages subdirectory deployment
                  li
                    strong I fixed it:
                    |  Custom <code>relativePath</code> filter that calculates paths dynamically
                  li
                    strong Then I closed the loop:
                    |  "Update SPEC.md and PLAN.md to document why pathPrefix failed and what works instead"
                  li.mt-2
                    strong Result:
                    |  SPEC.md now says "No environment-specific configuration." PLAN.md shows pathPrefix crossed out with the working alternative. Next developer won't try pathPrefix because the spec explains why it doesn't work.

            .card.mb-3
              .card-header.bg-light
                h6.card-title.mb-0
                  i.bi.bi-2-circle.me-2
                  | Warning Suppression: Spec Was Too Vague
              .card-body
                ul.list-unstyled.mb-0
                  li
                    strong AI generated:
                    |  <code>#pragma warning disable</code> directives (fastest solution)
                  li
                    strong Spec said:
                    |  "No suppressions" but didn't say HOW to fix properly
                  li
                    strong I fixed it:
                    |  200+ XML docs, null guards with <code>ArgumentNullException.ThrowIfNull()</code>
                  li
                    strong Then I closed the loop:
                    |  "Update SPEC.md with specific examples of acceptable vs. unacceptable fixes"
                  li.mt-2
                    strong Result:
                    |  SPEC.md now has a "✅ DO / ❌ DON'T" section. PLAN.md has a 5-step remediation strategy. TASKS.md breaks it into auditable chunks. Future features inherit this standard.

            .card.mb-3
              .card-header.bg-light
                h6.card-title.mb-0
                  i.bi.bi-3-circle.me-2
                  | Test Documentation: Spec Didn't Ask, AI Didn't Deliver
              .card-body
                ul.list-unstyled.mb-0
                  li
                    strong AI generated:
                    |  Documented library code, skipped test methods entirely
                  li
                    strong Spec said:
                    |  "520 tests passing" but not "tests need documentation"
                  li
                    strong I fixed it:
                    |  Added XML docs to 260 test methods explaining WHAT and WHY
                  li
                    strong Then I closed the loop:
                    |  "Update SPEC.md to require test documentation. Add principle to CONSTITUTION.md: 'Tests are product documentation.'"
                  li.mt-2
                    strong Result:
                    |  Every future spec inherits "tests need docs" standard. AI reads the constitution before generating code. The team's quality bar persists beyond individual developers.

            h3.h5.mb-3 Why This Solves a 40-Year-Old Problem

            p.mb-0.
              In waterfall, specs froze at design and diverged immediately. In agile, we stopped writing specs because maintaining them was humanly impossible. GitHub Spec Kit closes the loop: when implementation teaches you something, you spend 20 minutes having AI update the specs. The path resolution lesson, the warning fix patterns, the test documentation standard—all permanent institutional knowledge that AI agents read before generating the next feature. That's what survives team turnover.

          section#faq.mb-5
            h2.h3.mb-4
              i.bi.bi-question-circle.me-2
              | Frequently Asked Questions

            .accordion#faqAccordion
              .accordion-item
                h3.accordion-header#faq1
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapse1'
                    aria-expanded='false'
                    aria-controls='collapse1'
                    aria-label='Does this only work with GitHub Copilot?'
                  )
                    i.bi.bi-question-circle-fill.me-2
                    | Does this only work with GitHub Copilot?
                .accordion-collapse.collapse#collapse1(
                  aria-labelledby='faq1'
                  data-bs-parent='#faqAccordion'
                )
                  .accordion-body.
                    No. The pattern is model-agnostic. Any LLM benefits from structured specs and tests.

              .accordion-item
                h3.accordion-header#faq2
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapse2'
                    aria-expanded='false'
                    aria-controls='collapse2'
                    aria-label='Is this just test-driven development?'
                  )
                    i.bi.bi-question-circle-fill.me-2
                    | Isn't this just test-driven development?
                .accordion-collapse.collapse#collapse2(
                  aria-labelledby='faq2'
                  data-bs-parent='#faqAccordion'
                )
                  .accordion-body.
                    It's complementary. Spec Kit codifies requirements and examples up front, then TDD validates them. The twist is that you're writing for humans and an AI partner simultaneously.

              .accordion-item
                h3.accordion-header#faq3
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapse3'
                    aria-expanded='false'
                    aria-controls='collapse3'
                    aria-label='What if my problem is too open-ended for a spec?'
                  )
                    i.bi.bi-question-circle-fill.me-2
                    | What if my problem is too open-ended for a spec?
                .accordion-collapse.collapse#collapse3(
                  aria-labelledby='faq3'
                  data-bs-parent='#faqAccordion'
                )
                  .accordion-body.
                    Break it into spec-able slices. Use research spikes to learn, then spec the actionable parts.

              .accordion-item
                h3.accordion-header#faq4
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapse4'
                    aria-expanded='false'
                    aria-controls='collapse4'
                    aria-label='What if Copilot still gets it wrong?'
                  )
                    i.bi.bi-question-circle-fill.me-2
                    | What if Copilot still gets it wrong?
                .accordion-collapse.collapse#collapse4(
                  aria-labelledby='faq4'
                  data-bs-parent='#faqAccordion'
                )
                  .accordion-body.
                    Tighten the spec, add failing tests for the misbehavior, and iterate. Avoid changing code and spec in opposite directions.

          section#workflow.mb-5
            h2.h3.mb-4
              i.bi.bi-arrow-repeat.me-2
              | Following the Spec Kit Flow

            p.mb-4.
              Ready to try it yourself? Here's the recommended workflow with the slash commands that guide Copilot through each phase. Each command has a specific purpose and builds on the previous steps.

            .table-responsive.mb-4
              table.table.table-bordered.table-hover(aria-label='Spec Kit workflow commands')
                thead.table-light
                  tr
                    th.text-center Step
                    th Command
                    th Purpose
                    th When to Use
                tbody
                  tr
                    td.text-center.fw-bold 1
                    td
                      code.text-primary /speckit.constitution
                    td Define your quality principles and coding standards
                    td Once per project - sets foundational guidelines
                  tr
                    td.text-center.fw-bold 2
                    td
                      code.text-primary /speckit.specify
                    td Declare WHAT to build and WHY it matters
                    td Start of each feature/spec - defines the goal
                  tr
                    td.text-center.fw-bold 3
                    td
                      code.text-primary /speckit.clarify
                    td Answer ambiguities and edge cases
                    td After specify - usually just once to refine requirements
                  tr
                    td.text-center.fw-bold 4
                    td
                      code.text-primary /speckit.plan
                    td Determine HOW to implement (tools, versions, approach)
                    td Before coding - establishes technical strategy
                  tr
                    td.text-center.fw-bold 5
                    td
                      code.text-primary /speckit.tasks
                    td Break work into discrete, testable chunks
                    td After planning - creates actionable task list
                  tr
                    td.text-center.fw-bold 6
                    td
                      code.text-primary /speckit.analyze
                    td Optional sanity check before execution
                    td For complex specs - validates approach before commit
                  tr
                    td.text-center.fw-bold 7
                    td
                      code.text-primary /speckit.implement
                    td Execute the plan with Copilot
                    td Final step - let AI generate the code

            .alert.alert-info.mb-4
              h6.alert-heading.mb-2
                i.bi.bi-info-circle.me-2
                | Example Flow: Warning Cleanup Spec
              p.mb-2.
                For a spec like "eliminate all compiler warnings", you'd follow this sequence:
              ol.mb-0
                li
                  strong /speckit.constitution:
                  |  "We treat warnings as errors. No pragma suppressions without justification."
                li
                  strong /speckit.specify:
                  |  "WHAT: Zero warnings with TreatWarningsAsErrors enabled. WHY: Professional code quality and prevent tech debt."
                li
                  strong /speckit.clarify:
                  |  "Do we need XML docs on internal classes? No, public APIs only."
                li
                  strong /speckit.plan:
                  |  ".NET 8.0/9.0 multi-targeting. Use ArgumentNullException.ThrowIfNull(). Configure .editorconfig."
                li
                  strong /speckit.tasks:
                  |  "1) Baseline audit, 2) XML docs, 3) Null guards, 4) Analyzer config, 5) Verify build."
                li
                  strong /speckit.analyze:
                  |  "Spot-check: Will this break any public APIs? No - only adding docs and guards."
                li
                  strong /speckit.implement:
                  |  "Execute tasks, run tests after each phase, commit incrementally."

            p.mb-0.
              The power of this flow is that each step constrains Copilot's focus. Instead of trying to solve everything at once, you guide it through a logical progression that produces reliable, well-documented results.

            h3.h5.mb-3.mt-4 The Critical Step: Close the Documentation Loop

            p.mb-3.
              Here's the reality: after <code>/speckit.implement</code> completes, you'll tweak edge cases, adjust UX, and fix bugs the AI missed. This iteration is expected and normal. What's different is what you do next.

            .alert.alert-warning.mb-4
              h6.alert-heading.mb-2
                i.bi.bi-exclamation-triangle-fill.me-2
                | THIS is Where the Value Lives
              p.mb-2.
                When you finally get it right, <strong>tell the agent to update SPEC.md, PLAN.md, and TASKS.md</strong> to reflect what you actually built. This 20-minute step is what traditional approaches skip—and why documentation always becomes outdated.
              p.mb-0.small.
                Example: "I fixed the GitHub Pages path resolution by implementing a custom relativePath filter. Please update SPEC.md and PLAN.md to reflect this solution instead of the original pathPrefix approach, and explain why pathPrefix failed."

            .row.g-3.mb-4
              .col-lg-6
                .card.border-danger.h-100
                  .card-header.bg-light
                    h6.card-title.mb-0
                      i.bi.bi-x-circle.me-2.text-danger
                      | Without Feedback Loop
                  .card-body
                    ul.mb-0.small
                      li Specs describe what you planned, not what you built
                      li Future developers follow outdated documentation
                      li Institutional knowledge lives only in your head
                      li Next feature repeats the same mistakes

              .col-lg-6
                .card.border-success.h-100
                  .card-header.bg-light
                    h6.card-title.mb-0
                      i.bi.bi-check-circle.me-2.text-success
                      | With Feedback Loop
                  .card-body
                    ul.mb-0.small
                      li Specs evolve to match reality (living documentation)
                      li Future developers see what actually works
                      li Team learns from real-world implementation
                      li Each spec becomes more accurate over time

            p.mb-0.
              The feedback loop keeps specs synchronized with reality. Your specs document what you built and what you learned—useful for your future self and your team.

          section#conclusion.mb-5
            h2.h3.mb-4
              i.bi.bi-trophy.me-2
              | Conclusion: Institutional Knowledge That Survives Team Turnover

            p.lead.mb-4.
              The win wasn't 7-hour implementation—it was specs that still accurately describe the codebase three months later. Path resolution decisions, warning remediation strategies, test documentation standards—all captured in markdown that AI reads before generating new features. That's institutional knowledge that survives team turnover, not tribal knowledge that walks out the door.

            h3.h5.mb-3 Use Spec Kit When:

            ul.mb-4
              li
                strong Institutional knowledge matters:
                |  Libraries, APIs, multi-year projects where team turnover is inevitable
              li
                strong Multiple developers:
                |  When onboarding cost of inaccurate documentation compounds over time
              li
                strong Long-term maintenance:
                |  Projects that will be maintained beyond the original author
              li
                strong Compliance requirements:
                |  When you need audit trails and documented decision rationale
              li
                strong Complex domain logic:
                |  When tribal knowledge creates single points of failure

            h3.h5.mb-3 Skip Spec Kit When:

            ul.mb-4
              li
                strong Throwaway prototypes:
                |  POCs you'll rewrite from scratch if successful
              li
                strong Solo projects with short lifespans:
                |  Personal tools you'll maintain alone for 6 months
              li
                strong Exploratory work:
                |  Research spikes where requirements are genuinely unknown
              li
                strong Trivial features:
                |  Single-file utilities that don't need coordination
              li
                strong Time-critical emergencies:
                |  Production fires where documentation can wait

            .alert.alert-success.mb-4
              h6.alert-heading.mb-2
                i.bi.bi-check-circle-fill.me-2
                | What This Project Delivered: Persistent Knowledge
              ul.mb-0
                li
                  strong Path resolution pattern:
                  |  Custom relativePath filter documented in specs—future developers won't repeat the pathPrefix mistake
                li
                  strong Warning remediation strategy:
                  |  XML docs + ArgumentNullException.ThrowIfNull() pattern captured in PLAN.md—team inherits the standard
                li
                  strong Test documentation philosophy:
                  |  "Tests are product documentation" principle added to CONSTITUTION.md—applies to all future features
                li
                  strong Specs that match reality:
                  |  Documentation updated after implementation reflects what actually works, not what was initially planned
                li
                  strong Zero documentation debt:
                  |  20 minutes to sync specs vs. never updating them = institutional knowledge that survives team turnover

            p.mb-0.
              Start small: one .specify/ directory, one SPEC.md with clear acceptance criteria. After implementation, spend 20 minutes having the agent update the spec to match what you actually built. Six months later, you'll thank yourself for the accurate documentation.

extends ../layouts/modern-layout

block variables
  - var pageTitle = 'Building Real-Time Chat with React, SignalR, and Markdown Streaming'
  - var pageDescription = 'Learn how to build a real-time React chat app with TypeScript, SignalR for live messaging, and streaming Markdown rendering. Step-by-step integration and demonstration included.'
  - var pageKeywords = 'React chat app, TypeScript, SignalR, real-time messaging, Markdown streaming, interactive UI, AI-enhanced chat, live updates'
  - var pageCanonical = 'https://markhazleton.com/articles/building-real-time-chat-with-react-signalr-and-markdown-streaming.html'

block pagehead
  title= pageTitle
  meta(name='description', content=pageDescription)
  meta(name='keywords', content=pageKeywords)
  meta(name='author', content='Mark Hazleton')

block og_overrides
  meta(property='og:title', content=pageTitle)
  meta(property='og:description', content=pageDescription)
  meta(property='og:url', content=pageCanonical)
  meta(property='og:type', content='article')
  meta(property='og:video:url', content='https://www.youtube.com/embed/D82StHCr6ig')
  meta(property='og:video:secure_url', content='https://www.youtube.com/embed/D82StHCr6ig')
  meta(property='og:video:type', content='text/html')
  meta(property='og:video:width', content='560')
  meta(property='og:video:height', content='315')
  meta(property='og:image', content='https://img.youtube.com/vi/D82StHCr6ig/maxresdefault.jpg')
  meta(property='og:image:alt', content='Real-Time Chat Application Video Preview')

block twitter_overrides
  meta(name='twitter:card', content='player')
  meta(name='twitter:title', content=pageTitle)
  meta(name='twitter:description', content=pageDescription)
  meta(name='twitter:player', content='https://www.youtube.com/embed/D82StHCr6ig')
  meta(name='twitter:player:width', content='560')
  meta(name='twitter:player:height', content='315')
  meta(name='twitter:image', content='https://img.youtube.com/vi/D82StHCr6ig/maxresdefault.jpg')
block canonical
  link(rel='canonical', href=pageCanonical)

block additional_structured_data
  script(type='application/ld+json').
    {
      "@context": "http://schema.org",
      "@type": "VideoObject",
      "name": "Building Real-Time Chat with React, SignalR, and Markdown Streaming",
      "description": "Learn how to build a real-time React chat application with SignalR for live messaging and Markdown rendering.",
      "thumbnailUrl": "https://img.youtube.com/vi/D82StHCr6ig/maxresdefault.jpg",
      "uploadDate": "2024-10-27",
      "contentUrl": "https://markhazleton.com/articles/building-real-time-chat-with-react-signalr-and-markdown-streaming.html",
      "embedUrl": "https://www.youtube.com/embed/D82StHCr6ig",
      "publisher": {
        "@type": "Organization",
        "name": "Mark Hazleton",
        "logo": {
          "@type": "ImageObject",
          "url": "https://markhazleton.com/assets/img/MarkHazleton.jpg"
        }
      }
    }

block layout-content
  br
  article#main-article.py-5
    .container
      .row.justify-content-center
        .col-12.col-lg-10
          header.text-center.mb-5
            h1.display-4.fw-bold.text-primary
              i.bi.bi-chat-dots.me-3(aria-hidden='true')
              | Building Real-Time Chat
            h2.h3.text-muted.mb-4 Enhancing Real-Time Interactions with Adaptive Technologies
            .article-meta.text-muted.mb-4
              i.bi.bi-calendar3.me-2(aria-hidden='true')
              | Published: October 27, 2024
            p.lead.
              Explore how to build a real-time React chat application integrated with SignalR for live messaging and Markdown for streaming content rendering.
              Learn step-by-step integration and how these technologies can enhance interactive user experiences.

          // Video Demonstration Card
          .card.shadow-sm.mb-5
            .card-header.bg-primary.text-white
              h3.card-title.mb-0
                i.bi.bi-play-circle.me-2(aria-hidden='true')
                | Live Demonstration
            .card-body.p-0
              .ratio.ratio-16x9
                iframe(src='https://www.youtube.com/embed/D82StHCr6ig?si=q5KuO9Og3DIYsw66', title='Building Real-Time Chat with React, SignalR, and Markdown Streaming', frameborder='0', allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share', referrerpolicy='strict-origin-when-cross-origin', allowfullscreen)
            .card-footer.text-muted
              p.mb-0.
                Watch the demonstration to see how real-time chat applications are built with React, SignalR, and Markdown streaming. Gain insights into the tools and techniques used to create seamless chat experiences.

          // Introduction Card
          .card.shadow-sm.mb-5
            .card-header.bg-light
              h3.card-title.mb-0
                i.bi.bi-info-circle.me-2.text-primary(aria-hidden='true')
                | Project Overview
            .card-body
              .row
                .col-lg-8
                  p.
                    In my ongoing journey to learn React and TypeScript, I have been enhancing the site I built.
                    This post dives into integrating the site with my PromptSpark project by
                    linking it to the existing SignalR implementation.
                .col-lg-4
                  .card.border-secondary
                    .card-body.text-center
                      h5.card-title.text-primary Key Technologies
                      ul.list-unstyled.mb-0
                        li
                          i.bi.bi-chevron-right.text-success.me-2(aria-hidden='true')
                          | React & TypeScript
                        li
                          i.bi.bi-chevron-right.text-success.me-2(aria-hidden='true')
                          | SignalR Hub
                        li
                          i.bi.bi-chevron-right.text-success.me-2(aria-hidden='true')
                          | Markdown Streaming
                        li
                          i.bi.bi-chevron-right.text-success.me-2(aria-hidden='true')
                          | Vite Development

          // Development Process Card
          .card.shadow-sm.mb-5
            .card-header.bg-light
              h3.card-title.mb-0
                i.bi.bi-gear.me-2.text-primary(aria-hidden='true')
                | Development Process
            .card-body
              .accordion(id='developmentAccordion')
                .accordion-item
                  h4.accordion-header(id='headingOne')
                    button.accordion-button(type='button', data-bs-toggle='collapse', data-bs-target='#collapseOne', aria-expanded='true', aria-controls='collapseOne')
                      i.bi.bi-rocket.me-2.text-success(aria-hidden='true')
                      | Original Project Setup with Vite
                  #collapseOne.accordion-collapse.collapse.show(aria-labelledby='headingOne', data-bs-parent='#developmentAccordion')
                    .accordion-body
                      p.
                        Initially, I built my React site with Vite to benefit from fast development speeds,
                        simplified setup, and compatibility with TypeScript. Starting with the basics,
                        I created a functional and minimal site that allowed me to
                        explore React's component-based structure, state management, and simple user interactions.
                        Vite's zero-config setup was a great advantage,
                        allowing me to start coding immediately with hot-reloading and seamless builds.

                .accordion-item
                  h4.accordion-header(id='headingTwo')
                    button.accordion-button.collapsed(type='button', data-bs-toggle='collapse', data-bs-target='#collapseTwo', aria-expanded='false', aria-controls='collapseTwo')
                      i.bi.bi-broadcast.me-2.text-info(aria-hidden='true')
                      | Integrating PromptSpark with SignalR
                  #collapseTwo.accordion-collapse.collapse(aria-labelledby='headingTwo', data-bs-parent='#developmentAccordion')
                    .accordion-body
                      p.
                        The goal with this update was to connect my site to PromptSpark,
                        a tool I built to provide custom prompts for applications. I
                        wanted a chat bot experience with PromptSpark variants.
                        To achieve this, I leveraged the existing SignalR hub created to
                        facilitate two-way communication between users and the PromptSpark system.
                        SignalR's integration allows for real-time prompt suggestions and dynamic responses,
                        creating a more interactive user experience.

                .accordion-item
                  h4.accordion-header(id='headingThree')
                    button.accordion-button.collapsed(type='button', data-bs-toggle='collapse', data-bs-target='#collapseThree', aria-expanded='false', aria-controls='collapseThree')
                      i.bi.bi-puzzle.me-2.text-warning(aria-hidden='true')
                      | Reflections on Modular Development with React
                  #collapseThree.accordion-collapse.collapse(aria-labelledby='headingThree', data-bs-parent='#developmentAccordion')
                    .accordion-body
                      p.
                        By building on the foundation of my original site,
                        I could focus on integrating these new features without needing a major overhaul.
                        I took advantages of modular development with React and                        showcased the power of TypeScript and Vite for rapid development, even as requirements grow.

          // Technical Implementation Guide
          .card.shadow-sm.mb-5
            .card-header.bg-success.text-white
              h3.card-title.mb-0
                i.bi.bi-code-slash.me-2(aria-hidden='true')
                | Complete Implementation Guide
            .card-body
              .row.g-4
                // Setting up Project
                .col-lg-6
                  .card.h-100.border-primary
                    .card-header.bg-primary.text-white                      h5.card-title.mb-0
                        i.bi.bi-box.me-2(aria-hidden='true')
                        | Setting Up the Project
                    .card-body
                      p.
                        I started with my Portfolio project using Vite for fast development builds,
                        along with TypeScript and React.
                        For this effort, I needed to add integration with SignalR for real-time messaging and
                        `react-markdown` for rendering Markdown content.
                      pre.language-bash.bg-dark.text-light.p-3.rounded
                        code.language-bash.
                          npm install @microsoft/signalr react-markdown

                // SignalR Connection
                .col-lg-6
                  .card.h-100.border-info
                    .card-header.bg-info.text-white
                      h5.card-title.mb-0
                        i.bi.bi-broadcast.me-2(aria-hidden='true')
                        | Connecting to SignalR
                    .card-body
                      p.
                        One of the first tasks was configuring SignalR to enable real-time,
                        two-way communication between the server and the client.
                        In my `Chat.tsx` file, I created a `HubConnection` to connect to the server
                        and added an event listener to receive messages in real time.
                      pre.language-typescript.bg-dark.text-light.p-3.rounded
                        code.language-typescript.
                          import * as signalR from "@microsoft/signalr";
                          const connection = new signalR.HubConnectionBuilder()
                            .withUrl("/chatHub")
                            .build();

                          connection.on("ReceiveMessage", (user, message) => {
                            setMessages((prev) => [...prev, { user, message }]);
                          });

                // Chat UI Design
                .col-lg-6
                  .card.h-100.border-warning
                    .card-header.bg-warning.text-dark
                      h5.card-title.mb-0
                        i.bi.bi-layout-text-window.me-2(aria-hidden='true')
                        | Designing the Chat UI
                    .card-body
                      p.
                        The UI needed to be straightforward and mobile-responsive, so I used Bootstrap classes to quickly create the layout. I structured it with input fields for username and messages, a join button, and a display area for conversation-style messages.
                      pre.language-jsx.bg-dark.text-light.p-3.rounded
                        code.language-jsx.
                          return (
                            <div className="chat-container">
                              <input type="text" placeholder="Username" onChange={setUser} />
                              <input type="text" placeholder="Message" onChange={setMessage} />
                              <button onClick={sendMessage}>Join Chat</button>
                              <div className="messages-display">{messages.map(...)}</div>
                            </div>
                          );

                // Bot Integration
                .col-lg-6
                  .card.h-100.border-secondary
                    .card-header.bg-secondary.text-white
                      h5.card-title.mb-0
                        i.bi.bi-robot.me-2(aria-hidden='true')
                        | Bot with Customizable Tones
                    .card-body
                      p.
                        I wanted the chat app to feature a bot with customizable tones, such as helpful, funny, or pirate-themed responses. I achieved this by passing a `variantName` prop to customize each bot's tone, making it easy for users to choose a specific bot personality.
                      pre.language-typescript.bg-dark.text-light.p-3.rounded
                        code.language-typescript.
                          const BotResponse = ({ variantName }: { variantName: string }) => {
                            switch(variantName) {
                              case "pirate":
                                return "Arr! Ye message received!";
                              case "helpful":
                                return "How can I assist you today?";
                              // other variants
                            }
                          };

          // Advanced Features Card
          .card.shadow-sm.mb-5
            .card-header.bg-warning.text-dark
              h3.card-title.mb-0
                i.bi.bi-lightning-charge.me-2(aria-hidden='true')
                | Advanced Features
            .card-body
              .row.g-4
                // Streaming Responses
                .col-lg-6
                  .card.h-100.border-success
                    .card-header.bg-success.text-white
                      h5.card-title.mb-0
                        i.bi.bi-arrow-repeat.me-2(aria-hidden='true')
                        | Streaming Responses
                    .card-body
                      p.
                        To achieve a real-time, streaming experience, I implemented logic to accumulate bot responses in chunks, displaying the content as it streamed in. Using a `streamingMessage` state, the bot's responses would appear incrementally as data continued streaming from SignalR.
                      pre.language-typescript.bg-dark.text-light.p-3.rounded
                        code.language-typescript.
                          const [streamingMessage, setStreamingMessage] = useState("");
                          connection.on("StreamMessage", (chunk) => {
                            setStreamingMessage((prev) => prev + chunk);
                          });

                // Markdown Rendering
                .col-lg-6
                  .card.h-100.border-info
                    .card-header.bg-info.text-white
                      h5.card-title.mb-0
                        i.bi.bi-markdown.me-2(aria-hidden='true')
                        | Markdown Rendering
                    .card-body
                      p.
                        For a richer text experience, I used `react-markdown` to render bot responses with Markdown formatting. This allowed the bot to send formatted messages, including bold text, lists, and links.
                      pre.language-jsx.bg-dark.text-light.p-3.rounded
                        code.language-jsx.
                          import ReactMarkdown from "react-markdown";
                          <ReactMarkdown>{markdownContent}</ReactMarkdown>;

                // Incremental Loading
                .col-lg-6
                  .card.h-100.border-primary
                    .card-header.bg-primary.text-white
                      h5.card-title.mb-0
                        i.bi.bi-arrow-down-circle.me-2(aria-hidden='true')
                        | Incremental Loading
                    .card-body
                      p.
                        I added incremental message updates with the `FlatList` component's `ListFooterComponent`, allowing the UI to update as new Markdown chunks streamed in. This setup provided a seamless, real-time experience, with messages appearing as soon as they arrived.
                      pre.language-typescript.bg-dark.text-light.p-3.rounded
                        code.language-typescript.
                          <FlatList
                            data={messages}
                            renderItem={({ item }) => <ReactMarkdown>{item}</ReactMarkdown>}
                            ListFooterComponent={<div>{streamingMessage}</div>}
                          />

                // Error Management & Styling
                .col-lg-6
                  .card.h-100.border-danger
                    .card-header.bg-danger.text-white
                      h5.card-title.mb-0
                        i.bi.bi-exclamation-triangle.me-2(aria-hidden='true')
                        | Error Management & Styling
                    .card-body
                      p.
                        Throughout development, I encountered TypeScript errors, especially with type mismatches in components.
                        I solved these by refining types and ensuring all components aligned with TypeScript
                        and React standards. Additionally, I removed redundant CSS by relying more on Bootstrap utilities
                        for a cleaner, consistent style.
                      p.
                        For the final touches, I added Bootstrap Icons and styled components to keep the interface cohesive.
                        This approach streamlined the code and enhanced user experience with clean, responsive visuals.

          // Conclusion Card
          .card.shadow-sm.mb-5
            .card-header.bg-dark.text-white
              h3.card-title.mb-0
                i.bi.bi-check-circle.me-2(aria-hidden='true')
                | Conclusion
            .card-body
              p.lead.
                Building this chat app provided a deeper understanding of real-time communication,
                content streaming, and Markdown rendering in a React and TypeScript environment.
                It involved leveraging SignalR for bidirectional messaging, handling Markdown in real time,
                and creating dynamic bot personalities for a more engaging user experience.

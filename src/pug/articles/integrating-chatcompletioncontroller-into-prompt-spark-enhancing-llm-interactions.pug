extends ../layouts/articles

block pagehead
  title Integrating Chat Completion into Prompt Spark
  meta(name='description', content='Learn how the ChatCompletionController enhances LLM interactions in the Prompt Spark project by enabling seamless chat functionalities for Core Spark Variants.')
  meta(name="keywords" content="ChatCompletionController, Prompt Spark, LLM, AI Chat, AI Assistant, Core Spark, Spark Variants")
  meta(name='author', content='Mark Hazleton')
  link(rel='canonical', href='https://markhazleton.com/integrating-chatcompletioncontroller-into-prompt-spark')

block layout-content

  section#post.painteddesert-section.painteddesert-section-background
    .painteddesert-section-content
      h1 Integrating Chat Completion into Prompt Spark
      h2.subheading.mb-3 Learn how the Chat Completion enhances LLM interactions in the Prompt Spark project by using Microsoft.SemanticKernel to enable chat functionalities for Core Spark Variants.
      h3 Chat Completions: Revolutionizing System Design and User Interaction
      p.
        Since its public launch in November 2022, ChatGPT has captured global attention by demonstrating the extraordinary potential of Large Language Models (LLM).
        Generating human-like responses to a wide range of requests, from practical queries to surreal prompts,
        ChatGPT has drafted cover letters, composed poetry, and even pretended to be William Shakespeare.
        This revolutionary technology is changing how we design systems and interact with computers,
        offering a more natural and intuitive way for users to communicate with machines.
      p.
        The impact of these tools extends beyond mere novelty.
        They are reshaping the landscape of user interaction by providing seamless,
        conversational interfaces that can understand and respond to complex human inputs.
        This evolution presents a significant design challenge: creating contextually rich experiences that feel natural and engaging for users.
        By integrating chat completions into applications, we can enhance accessibility, streamline workflows, and revolutionize the way we work and communicate.
      p.
        The Chat Completion interface demands a shift in how designers and prompt engineers approach system design.
        Instead of static and linear interactions, these interfaces require dynamic and context-aware communication strategies.
        Designers must anticipate a wide array of user inputs and craft responses that are not only accurate but also contextually relevant.
        This involves understanding user intent, maintaining conversational flow, and adapting to the user's needs in real-time.

      h3 The Future of System Design and User Interaction
      p.
        Chat Completions transforming the way we work by enhancing efficiency, effectiveness, and speed.
        AI-powered chat completions optimize writing tasks, generating essays, memos, and other content.
        As we embrace these technologies, our challenge is to develop tools that aligns with human goals and educate users on their ethical use.
        Just as calculators didn't replace math education but became powerful tools,
        AI-mediated communication will continue to evolve, supporting our work while requiring thoughtful implementation.
      dl
        dt Traditional Interfaces to Dynamic Communication
        dd.
          The advent of chat completions is ushering in a new era of system design.
          Traditional interfaces are giving way to more dynamic and interactive modes of communication.
          Users now expect systems to understand natural language inputs and provide contextually relevant responses.
          This shift necessitates a redesign of user interfaces to accommodate conversational agents, making interactions more fluid and intuitive.
        dt Enhancing Accessibility
        dd.
          These advancements are enhancing accessibility,
          enabling users who may not be familiar with technical jargon or complex interfaces to interact with systems effortlessly.
          The democratization of technology through conversational AI is making powerful tools available to a broader audience,
          fostering inclusivity and engagement.
        dt Integration and Evolution
        dd.
          The integration of chat completions into various applications will continue to evolve.
          From customer support to personal assistants and beyond,
          the ability of AI to converse naturally and meaningfully with users will redefine our relationship with technology.
          The future of system design lies in creating seamless, user-centric interactions that leverage the full potential of AI-driven communication.

      h3 Chat Completions in Prompt Spark
      p.
        Chat Completion was added to the Prompt Spark project to demonstrate a chat, co-pilot, or assistant interface.
        This integration allows users to converse with spark variants derived from a given Core Spark,
        providing a practical and insightful way to evaluate their performance.

      a(href='https://gpt.frogsfolly.com', target='_blank' rel='noopener' ).btn.btn-primary
        img.img-fluid.d-block.w-100(src='/assets/img/MarkHazleton-PromptSpark-ChatCompletion.png' alt='Prompt Spark - Chat Completion ' title='Prompt Spark - Chat Completion')

      h2 Microsoft.SemanticKernel NuGet Package
        a.btn.btn-primary(href='https://learn.microsoft.com/en-us/semantic-kernel/overview/?tabs=Csharp' target='_blank') Learn More

      p.
        The Microsoft Semantic Kernel is an open-source SDK designed to help developers build AI agents by combining existing code with AI models from various providers like OpenAI, Azure, and Hugging Face. It functions as an AI orchestration layer, enabling the creation of agents that can automate tasks by calling existing code. This SDK allows for extensibility through plugins and connectors, making it easy to integrate various AI services and automate complex business processes.
      p.
        The Microsoft.SemanticKernel NuGet package offers an innovative SDK designed to integrate advanced Large Language Models (LLMs)
        with conventional programming languages such as C#, Python, and Java.
        This package provides developers with the tools to seamlessly incorporate AI-driven functionalities into their applications,
        leveraging the capabilities of platforms like OpenAI, Azure OpenAI, and Hugging Face.

      dl
        dt Key Features and Functionality
        dd
          dl
            dt Plugins
            dd.
              Semantic Kernel allows you to define and integrate plugins easily.
              These plugins can be described with simple attributes, enabling AI models to understand and use them effectively.
            dt Automatic Orchestration
            dd.
              The SDK includes advanced orchestration capabilities,
              where it can automatically generate and execute plans using AI,
              significantly reducing the manual coding effort required to achieve complex tasks.
            dt Multilingual Support
            dd.
              The package supports multiple languages, offering robust functionality in C#, Python, and Java.
              This ensures flexibility and accessibility for a wide range of developers,
              regardless of their preferred programming language.
            dt Ease of Use
            dd.
              Developers can quickly start using Semantic Kernel by installing the package and following straightforward setup instructions. Whether using .NET, Python, or Java, the initial setup involves adding the package, configuring API keys, and integrating basic sample code.
            dt Interactive Learning
            dd.
              For hands-on learning, the SDK provides Jupyter notebooks that showcase usage examples and code snippets,
              helping developers to quickly grasp the core concepts and functionalities of Semantic Kernel.

      h2 Adding Chat to Prompt Spark
      dl
        dt Background: Prompt Spark Solution
        dd
          p Prompt Spark is designed to help developers and businesses optimize the use of LLM models by effectively managing, tracking, and comparing system prompts. Here are the key components of the Prompt Spark solution:
          dl
            dt Core Sparks
            dd
              p Core Sparks define the essential behavior and output expectations for LLMs. They establish rigorous requirements and guidelines to ensure consistency and quality across all interactions.
            dt Spark Variants
            dd
              p A Spark Variant is an LLM implementation of a Core Spark. Variants are used to compare responses and conduct in-depth testing and analysis of different implementations of the same Core Spark.
            dt User Prompts
            dd
              p User Prompts are collections of test inputs designed for a Core Spark. These prompts are systematically run against various Variants to assess their effectiveness and adherence to the Core Spark specifications.

        dt Building the ChatCompletionController
        dd
          p The ChatCompletionController serves as a pivotal element in the Prompt Spark project, enabling real-time, AI-driven conversations with different LLM Variants. Hereâ€™s a step-by-step breakdown of its implementation:
          dl
            dt Controller Setup
            dd
              p.
                The `ChatCompletionController` setup in the Prompt Spark project is designed to initialize and configure essential components through dependency injection.
                By injecting services the controller gains access to HTTP context for session management, real-time client communication, chat completion functionalities, GPT definitions,
                and logging capabilities. This setup ensures that the controller can efficiently manage chat interactions, storing and retrieving necessary data, and sending real-time updates to clients.
              p.
                This modular approach enhances the maintainability and testability of the application, as each service can be easily replaced or mocked during testing.
                It promotes a clear separation of concerns, where each service handles a specific aspect of the controller's operations, contributing to a scalable architecture.
                This configuration aligns with the goals of Prompt Spark, providing a robust framework for managing and comparing LLM interactions,
                ensuring consistency and quality in AI-driven chat functionalities.

              pre.language-csharp
                code.language-csharp.
                  public class ChatCompletionController(
                    IHttpContextAccessor _httpContextAccessor,
                    IHubContext<ChatHub> hubContext,
                    IChatCompletionService _chatCompletionService,
                    IGPTDefinitionService definitionService,
                    ILogger<ChatCompletionController> logger) : OpenAIBaseController


            dt Index Action
            dd
              p.
                The `Index` action in the `ChatCompletionController` serves as the initial entry point for setting up a chat session based on a specific GPT definition.
                When a request is made to this action with an optional `id` parameter, it checks if the `id` is zero and redirects to the default chat view if necessary.
                If a valid `id` is provided, it retrieves the corresponding GPT definition using the `IGPTDefinitionService` and serializes this information into a session variable.
                This setup ensures that subsequent requests within the session can access the necessary GPT definition details, facilitating a seamless chat experience.
              p.
                The purpose of this action is to prepare the chat environment by loading the appropriate definition data,
                which includes the core prompts and configurations for the chat session. By storing the `DefinitionDto` in the session,
                the application maintains stateful information that can be used across multiple interactions,
                enhancing the user experience by ensuring that each chat session is contextually aware
                and properly configured based on the selected GPT definition.
                This approach aligns with Prompt Spark's goal of optimizing and managing LLM interactions efficiently.

              pre.language-csharp
                code.language-csharp.
                  public async Task<IActionResult> Index(int id = 0)
                    {
                      if (id == 0) Response.Redirect("/OpenAI/Chat");
                      var definitionDto = await definitionService.GetDefinitionDtoAsync(id);
                      var session = _httpContextAccessor.HttpContext.Session;
                      session.SetString("DefinitionDto", JsonConvert.SerializeObject(definitionDto));
                      return View(definitionDto);
                    }

            dt SendMessage Action
            dd
              p.
                The `SendMessage` action in the `ChatCompletionController` processes user messages, managing the conversation flow between the user and the AI system.
                It retrieves the stored `DefinitionDto` from the session, which contains the core prompts and configurations for the chat.
                The action then constructs the chat history by incorporating system messages and parsing the conversation history provided in the request.
                This setup ensures that the AI has the necessary context to generate appropriate responses.
              p.
                The primary function of this action is to facilitate real-time communication using SignalR.
                It streams the AI's responses to the client, converting the content to HTML format before sending it.
                The action also includes robust error handling, logging any issues that occur during the process.
                This approach ensures a dynamic and responsive chat experience,
                aligning with Prompt Spark's objective of optimizing LLM interactions by maintaining context and providing immediate feedback to users.

              pre.language-csharp
                code.language-csharp.
                  [HttpPost]
                  public async Task<IActionResult> SendMessage([FromForm] string message, [FromForm] string conversationHistory) {
                    var session = _httpContextAccessor.HttpContext.Session;
                    var definitionDtoJson = session.GetString("DefinitionDto");
                    var definitionDto = JsonConvert.DeserializeObject<DefinitionDto>(definitionDtoJson);

                    if (!string.IsNullOrEmpty(message)) {
                      var chatHistory = new ChatHistory();
                      chatHistory.AddSystemMessage(definitionDto.Prompt);
                      chatHistory.AddSystemMessage("You are in a conversation, keep your answers brief, always ask follow-up questions, ask if ready for full answer.");

                      var messages = JsonConvert.DeserializeObject<List<string>>(conversationHistory);

                      for (int i = 0; i < messages.Count; i++) {
                        if (i % 2 == 0) {
                          chatHistory.AddUserMessage(messages[i]);
                        } else {
                          chatHistory.AddSystemMessage(messages[i]);
                        }
                      }

                      try {
                        var buffer = new StringBuilder();

                        await foreach (var response in _chatCompletionService.GetStreamingChatMessageContentsAsync(chatHistory)) {
                          if (response?.Content != null) {
                            buffer.Append(response.Content);
                            if (response.Content.Contains('\n')) {
                              var contentToSend = buffer.ToString();
                              var htmlContent = Markdown.ToHtml(contentToSend);
                              await hubContext.Clients.All.SendAsync("ReceiveMessage", "System", htmlContent);
                              buffer.Clear();
                            }
                          }
                        }

                        if (buffer.Length > 0) {
                          var remainingContent = buffer.ToString();
                          var htmlContent = Markdown.ToHtml(remainingContent);
                          await hubContext.Clients.All.SendAsync("ReceiveMessage", "System", htmlContent);
                        }
                      } catch (Exception ex) {
                        logger.LogError(ex, "Error occurred while processing the request");
                      }
                      return Ok();
                    }
                    logger.LogError("Invalid input");
                    return BadRequest("Invalid input");
                  }

        dt Benefits of Chat Completion in Prompt Spark
        dd
          dl
            dt Enhanced Interactivity
            dd By leveraging real-time chat functionalities, users can interact dynamically with different LLM variants, providing immediate feedback and insights.
            dt Improved Testing and Evaluation
            dd The ability to converse with multiple LLM variants based on a single Core Spark allows for comprehensive testing and performance comparison, ensuring adherence to quality standards.
            dt Efficient Prompt Management
            dd Storing and managing conversation histories and definition DTOs within session states streamline the process of tracking and analyzing interactions.

      p.
        Integrating Chat Completion into the Prompt Spark project demostrates a new capability to manage and evaluate LLM interactions.
        This demonstrates the practical implementation of a chat interface but also provides a valuable tool for developers to optimize their use of LLM models throgh prompt engineering.
      p Visit Prompt Spark to explore its capabilities and elevate your prompt engineering projects.
        a(href='https://gpt.frogsfolly.com', target='_blank' rel='noopener' alt='Explore Prompt Spark - LLM Prompt Managment Tool' title='Explore Prompt Spark - LLM Prompt Managment Tool' ).btn.btn-primary Explore Prompt Spark - LLM Prompt Managment Tool


extends ../layouts/modern-layout

block pagehead
  title AI Observability Is No Joke
  meta(name='description', content='A  humorous look at AI observability through the lens of a joke-fetching agent. Learn why knowing what your AI did matters.')
  meta(name='keywords', content='AI, observability, debugging, agent, logging, best practices, transparency, accountability, Mark Hazleton')
  meta(name='author', content='Mark Hazleton')

block canonical
  link(rel='canonical', href='https://markhazleton.com/articles/ai-observability-is-no-joke.html')

block og_overrides
  meta(property='og:title', content='AI Observability Is No Joke')
  meta(property='og:description', content='A  humorous look at AI observability through the lens of a joke-fetching agent. Learn why knowing what your AI did matters.')
  meta(property='og:url', content='https://markhazleton.com/articles/ai-observability-is-no-joke.html')
  meta(property='og:type', content='article')

block twitter_overrides
  meta(name='twitter:title', content='AI Observability Is No Joke')
  meta(name='twitter:description', content='A  humorous look at AI observability through the lens of a joke-fetching agent. Learn why knowing what your AI did matters.')

block layout-content
  br

  // Hero Section
  section.bg-gradient-primary.py-5
    .container
      .row.align-items-center
        .col-lg-10.mx-auto.text-center
          h1.display-4.fw-bold.mb-3
            i.bi.bi-lightbulb.me-3
            | AI Observability Is No Joke
          p.lead.mb-4
            | A humorous look at AI observability through the lens of a joke-fetching agent.
            | Learn why knowing what your AI did matters.

          // Article Metadata
          .mb-4.text-muted.d-flex.justify-content-center.align-items-center.gap-4
            span
              i.bi.bi-person.me-1
              | Mark Hazleton
            span
              i.bi.bi-calendar.me-1
              | June 16, 2025
            span
              i.bi.bi-tag.me-1
              | AI, Observability

  // Main Article Content
  article#main-article
    .container
      .row
        .col-lg-9.mx-auto

          // Article Content Section
          section#article-content.mb-5

            // Introduction
            .alert.alert-info.mb-4
              p.mb-0
                i.bi.bi-info-circle.me-2
                strong What you'll learn:
                | How a simple AI joke request revealed critical observability gaps, why transparency matters in AI systems, and practical steps to implement better monitoring in your AI agents.

            h2.h3.mb-3.text-primary.d-flex.align-items-center
              i.bi.bi-emoji-laughing.me-2
              | A funny request turned into a lesson on AI observability
            p.lead.mb-4.
              I thought I was just asking for a joke.
              Turns out, I stumbled into one of the challenges facing AI development today.
              And honestly? Here's what unfolded—and why it matters.
            p.mb-3.
              Picture this: I'm tinkering with my latest AI agent setup, feeling pretty proud of myself.
              I've got my simple MCP (Model Context Protocol) server running, connected to jokeapi.com,
              ready to fetch the freshest jokes from the internet.
              My agent is configured, the tools are registered,
              everything looks perfect.
              So I typed: "Hey agent, tell me a joke."
            blockquote.blockquote.bg-light.p-3.border-start.border-4.border-primary.mb-3
              i.bi.bi-quote.me-2.text-primary
              | "Why don't scientists trust atoms? Because they make up everything!"
            p.mb-3.
              I chuckle. Mission accomplished, right? My agent used the API, grabbed a joke,
              delivered the goods. Time to pat myself on the back and move on to the next project.
              But then that little voice in my head started whispering. "Just where did that joke come from?"
            p.mb-3.
              I mean, sure, my agent said it fetched it from jokeapi.com.
              But did it really? Or did it just pull that gem from the vast
              repository of dad jokes floating around in its training data? How would I even know?
            p.mb-3.
              This is when I realized that while I had written the code, I had no idea of how it worked.
              Everything looks fine from the outside, but I had no clue as to what was happening under the hood.
            p.mb-3.
              Trying to answer the question of what was going on, I decided to dig deeper.
              I started looking at my logs,
              my network traffic, my agent's behavior patterns. And what I found was...
              well, not much. My fancy AI agent was essentially a black box wrapped in promises.
            p.mb-3.
              The agent could claim it called the API.
              It could even format its response to look like it came from an external source.
              But proving it actually made that HTTP request? That was surprisingly difficult.
            p.mb-3.
              It's like asking someone if they actually went to the store
              or just grabbed leftover groceries from the fridge. Both could produce milk,
              but the source matters if you're trying to track your spending (or in my case, API costs).

            h2.h4.mb-3.text-info.d-flex.align-items-center
              i.bi.bi-eye.me-2
              | The Bigger Picture
            p.mb-3.
              This seemingly simple joke request opened my eyes to a massive problem in AI agent development:
              observability. Not the most exciting word, I'll admit, but stick with me here.
            p.mb-3.
              Think about it this way - when you're driving, you have a dashboard.
              You can see your speed, fuel level, engine temperature.
              You know what's happening under the hood (mostly). But with AI agents?
              We're essentially driving blindfolded,
              hoping the agent is actually doing what it claims to be doing.
            p.mb-3.
              The more I thought about this, the funnier (and scarier) it became.
              I started imagining all the different ways my agent could be "fetching" that joke without actually calling the API.
              Imagine these scenarios:
            ul.list-group.mb-4
              li.list-group-item.d-flex.align-items-center
                i.bi.bi-rocket-takeoff.me-2.text-primary
                strong.me-2 The Overachiever:
                | Calls five APIs when one would do.
              li.list-group-item.d-flex.align-items-center
                i.bi.bi-moon.me-2.text-secondary
                strong.me-2 The Lazy Agent:
                | Fakes it with old data.
              li.list-group-item.d-flex.align-items-center
                i.bi.bi-question-circle.me-2.text-info
                strong.me-2 The Confused Agent:
                | Gives up silently but still logs success.
              li.list-group-item.d-flex.align-items-center
                i.bi.bi-person-gear.me-2.text-success
                strong.me-2 The Identity Crisis Agent:
                | Thinks it made a call… but didn’t.

            h2.h4.mb-3.text-danger.d-flex.align-items-center
              i.bi.bi-exclamation-triangle.me-2
              | Why This Matters
            p.mb-3.
              This isn't just about jokes or my particular brand of overthinking.
              As AI agents become more sophisticated and handle more critical tasks,
              this observability gap becomes genuinely problematic:
            dl.row.mb-4
              dt.col-sm-3.fw-bold.d-flex.align-items-center
                i.bi.bi-people.me-2.text-primary
                | Customer Service:
              dd.col-sm-9.mb-2
                | Did the agent actually check your account status, or is it giving you a generic response?
              dt.col-sm-3.fw-bold.d-flex.align-items-center
                i.bi.bi-currency-dollar.me-2.text-success
                | Financial Applications:
              dd.col-sm-9.mb-2
                | When the agent says it's pulling real-time market data, is it really, or are you making decisions based on stale information?
              dt.col-sm-3.fw-bold.d-flex.align-items-center
                i.bi.bi-heart-pulse.me-2.text-danger
                | Healthcare:
              dd.col-sm-9.mb-2
                | If an AI assistant claims to have checked the latest research, you'd better hope it actually did.
              dt.col-sm-3.fw-bold.d-flex.align-items-center
                i.bi.bi-code-slash.me-2.text-info
                | Development:
              dd.col-sm-9.mb-2
                | When your coding assistant says it's following best practices from the latest documentation, did it actually access that documentation or just wing it?
            p.mb-3.
              AI agents touch everything—from customer service to healthcare. We must know what they actually do, not just what they say they do.

            p.mb-3.
              Agents chain actions across tools and APIs. Without logs and proofs, it's a game of telephone with hallucinations.

            h2.h4.mb-3.text-primary.d-flex.align-items-center
              i.bi.bi-shield-check.me-2
              | Observability Best Practices
            p.mb-3.
              So, what can we do? Here are some best practices I'm adopting to ensure my AI agents are more transparent and accountable:
            ul.list-group.mb-4
              li.list-group-item.d-flex.align-items-center
                i.bi.bi-patch-check.me-2.text-success
                strong.me-2 Trust, but Verify:
                | Don't just ask—prove it.
              li.list-group-item.d-flex.align-items-center
                i.bi.bi-journal-text.me-2.text-info
                strong.me-2 Embrace Logs:
                | Log intent, attempts, and failures.
              li.list-group-item.d-flex.align-items-center
                i.bi.bi-bounding-box.me-2.text-warning
                strong.me-2 Test Boundaries:
                | Disable tools and see if the agent notices.
              li.list-group-item.d-flex.align-items-center
                i.bi.bi-tools.me-2.text-primary
                strong.me-2 Build for Observability:
                | Make it foundational, not an afterthought.
            p.mb-3.
              That joke? Still funny. But if my agent were making business decisions, I'd want proof. The joke's on us if we don't demand it.

            h2.h4.mb-3.text-secondary.d-flex.align-items-center
              i.bi.bi-book.me-2
              | Model Context Protocol (MCP) Glossary
            p.mb-3.
              Since MCP is central to this discussion, here's a comprehensive glossary of key terms and concepts
              that will help you understand how this protocol enables AI agent observability.

            .accordion#mcpGlossary.mb-5
              .accordion-item
                h3.accordion-header#headingMCP
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapseMCP'
                    aria-expanded='false'
                    aria-controls='collapseMCP'
                  )
                    i.bi.bi-diagram-3.me-2
                    | Model Context Protocol (MCP)
                .accordion-collapse.collapse#collapseMCP(
                  aria-labelledby='headingMCP'
                  data-bs-parent='#mcpGlossary'
                )
                  .accordion-body
                    p.
                      MCP is an open standard that enables secure, bidirectional communication between AI language models
                      and external data sources and tools. Think of it as a universal translator that allows AI agents
                      to safely interact with your databases, APIs, file systems, and other resources without exposing
                      sensitive information or compromising security. The protocol standardizes how AI systems request
                      access to resources, how they authenticate, and how data flows between the AI and external systems.

              .accordion-item
                h3.accordion-header#headingServer
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapseServer'
                    aria-expanded='false'
                    aria-controls='collapseServer'
                  )
                    i.bi.bi-server.me-2
                    | MCP Server
                .accordion-collapse.collapse#collapseServer(
                  aria-labelledby='headingServer'
                  data-bs-parent='#mcpGlossary'
                )
                  .accordion-body
                    p.
                      An MCP server is a standalone program that exposes specific capabilities (tools, resources, or prompts)
                      to AI clients through the MCP protocol. Servers act as secure gateways between AI agents and external
                      systems. For example, a database MCP server might provide read-only access to customer records,
                      while a file system server could allow an AI to read documentation files. Each server defines what
                      operations are allowed and implements appropriate security controls and logging.

              .accordion-item
                h3.accordion-header#headingClient
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapseClient'
                    aria-expanded='false'
                    aria-controls='collapseClient'
                  )
                    i.bi.bi-cpu.me-2
                    | MCP Client
                .accordion-collapse.collapse#collapseClient(
                  aria-labelledby='headingClient'
                  data-bs-parent='#mcpGlossary'
                )
                  .accordion-body
                    p.
                      The MCP client is typically an AI application or agent that connects to one or more MCP servers to
                      access external capabilities. Clients discover available tools and resources, make requests to servers,
                      and handle responses. Popular AI platforms like Claude Desktop, ChatGPT Plus, and custom AI applications
                      can act as MCP clients. The client is responsible for managing connections, handling authentication,
                      and presenting available tools to the AI model in a format it can understand and use.

              .accordion-item
                h3.accordion-header#headingTools
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapseTools'
                    aria-expanded='false'
                    aria-controls='collapseTools'
                  )
                    i.bi.bi-tools.me-2
                    | Tools
                .accordion-collapse.collapse#collapseTools(
                  aria-labelledby='headingTools'
                  data-bs-parent='#mcpGlossary'
                )
                  .accordion-body
                    p.
                      In MCP terminology, tools are specific functions or capabilities that an MCP server exposes to AI clients.
                      Tools define what actions an AI can perform—like querying a database, calling an API, or processing a file.
                      Each tool has a defined schema that specifies required parameters, expected inputs, and output formats.
                      Tools are stateless and designed to be called multiple times safely. Examples include "search_database",
                      "send_email", "create_calendar_event", or "fetch_weather_data". The tool abstraction allows AI agents
                      to understand and use complex external systems through simple, well-defined interfaces.

              .accordion-item
                h3.accordion-header#headingResources
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapseResources'
                    aria-expanded='false'
                    aria-controls='collapseResources'
                  )
                    i.bi.bi-folder.me-2
                    | Resources
                .accordion-collapse.collapse#collapseResources(
                  aria-labelledby='headingResources'
                  data-bs-parent='#mcpGlossary'
                )
                  .accordion-body
                    p.
                      Resources in MCP represent data or content that AI agents can access through the protocol. Unlike tools
                      (which perform actions), resources provide information. They can be static (like configuration files)
                      or dynamic (like real-time sensor data). Resources have URIs for identification and can include metadata
                      about their content type, size, and freshness. Examples include log files, documentation, database snapshots,
                      or API responses. Resources enable AI agents to access contextual information needed to make informed
                      decisions or provide accurate responses.

              .accordion-item
                h3.accordion-header#headingPrompts
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapsePrompts'
                    aria-expanded='false'
                    aria-controls='collapsePrompts'
                  )
                    i.bi.bi-chat-text.me-2
                    | Prompts
                .accordion-collapse.collapse#collapsePrompts(
                  aria-labelledby='headingPrompts'
                  data-bs-parent='#mcpGlossary'
                )
                  .accordion-body
                    p.
                      MCP prompts are reusable templates or instructions that servers can provide to AI clients. They help
                      standardize how AI agents interact with specific systems or perform particular tasks. Prompts can include
                      context about how to use tools effectively, what information to gather, or how to format responses.
                      They act as "best practice guides" built into the protocol, ensuring that AI agents use external systems
                      correctly and consistently. For example, a customer service MCP server might provide prompts that guide
                      an AI on how to handle different types of customer inquiries.

              .accordion-item
                h3.accordion-header#headingTransport
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapseTransport'
                    aria-expanded='false'
                    aria-controls='collapseTransport'
                  )
                    i.bi.bi-arrow-left-right.me-2
                    | Transport Layer
                .accordion-collapse.collapse#collapseTransport(
                  aria-labelledby='headingTransport'
                  data-bs-parent='#mcpGlossary'
                )
                  .accordion-body
                    p.
                      The transport layer in MCP handles the actual communication between clients and servers. MCP supports
                      multiple transport mechanisms including stdio (standard input/output for local processes), SSE (Server-Sent Events
                      for web-based communication), and WebSocket connections for real-time bidirectional communication. The transport
                      layer is responsible for message delivery, connection management, and basic error handling. Different transports
                      are optimized for different deployment scenarios—stdio for local development, SSE for simple web integrations,
                      and WebSockets for high-performance applications requiring real-time updates.

              .accordion-item
                h3.accordion-header#headingObservability
                  button.accordion-button.collapsed(
                    type='button'
                    data-bs-toggle='collapse'
                    data-bs-target='#collapseObservability'
                    aria-expanded='false'
                    aria-controls='collapseObservability'
                  )
                    i.bi.bi-eye.me-2
                    | MCP Observability Features
                .accordion-collapse.collapse#collapseObservability(
                  aria-labelledby='headingObservability'
                  data-bs-parent='#mcpGlossary'
                )
                  .accordion-body
                    p.
                      MCP includes built-in features that support observability and monitoring of AI agent interactions.
                      The protocol includes request/response logging, error reporting, and progress tracking mechanisms.
                      Servers can emit detailed logs about tool calls, resource access, and performance metrics. The standardized
                      message format makes it easier to implement monitoring dashboards, audit trails, and debugging tools.
                      This is exactly why MCP is so valuable for solving the observability challenges discussed in this article—it
                      provides a structured way to track what AI agents are actually doing when they interact with external systems.
            h2.h4.mb-3.text-dark.d-flex.align-items-center
              i.bi.bi-lightning-charge.me-2
              | Code Samples
            p.mb-3.
              For those interested in diving deeper, here is the simple C# code snippet that demonstrates
              how to implement MCP servers and tools for my basic joke-fetching tool.
              With no observability.
              Notice the lack of logging or proof of API calls.
            h3.h5.mb-3.text-primary.d-flex.align-items-center MCP Server
            pre.language-csharp
              code.language-csharp.
                // Create a generic host builder for
                // dependency injection, logging, and configuration.
                var builder = Host.CreateApplicationBuilder(args);

                // Configure logging for better integration with MCP clients.
                builder.Logging.AddConsole(consoleLogOptions =>
                {
                  consoleLogOptions.LogToStandardErrorThreshold = LogLevel.Trace;
                });

                // Register the MCP server and configure it to use stdio transport.
                // Scan the assembly for tool definitions.
                builder.Services
                  .AddMcpServer()
                  .WithStdioServerTransport()
                  .WithToolsFromAssembly();

                // Register HttpClient for API calls
                builder.Services.AddHttpClient();

                // Build and run the host. This starts the MCP server.
                await builder.Build().RunAsync();

            h3.h5.mb-3.text-secondary.d-flex.align-items-center Joke Tool
            pre.language-csharp
              code.language-csharp.
                /// <summary>
                /// Tool implementations using static methods
                /// </summary>
                public static class Tools
                {

                  /// <summary>
                  /// Fetches a random joke from JokeAPI
                  /// </summary>
                  /// <returns>A random programming joke</returns>
                  [Description("Fetches a random joke from JokeAPI")]
                  public static async Task<string> GetJoke()
                  {
                    using var client = new HttpClient();
                    try
                    {
                      var response = await client.GetFromJsonAsync<JokeResponse>(
                      "https://v2.jokeapi.dev/joke/Programming?safe-mode");

                      string joke = response?.Type == "single"
                      ? response.Joke ?? "No joke available"
                      : $"{response?.Setup}\n{response?.Delivery}";

                      return $"JOKE: {joke}";
                    }
                    catch (Exception ex)
                    {
                      return $"Error fetching joke: {ex.Message}";
                    }
                  }
                }

            h2.h4.mb-3.text-dark.d-flex.align-items-center
              i.bi.bi-lightning-charge.me-2
              | Final Thoughts
            p.mb-3.
              We need to ask harder questions of our AI systems. Not "can they do it?"—but "did they actually do it?" Because in the end, observability isn’t optional. It’s essential.


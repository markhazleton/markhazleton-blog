extends ../layouts/modern-layout

block layout-content
  br
  // Hero Section
  section.bg-gradient-primary.py-5
    .container
      .row.align-items-center
        .col-lg-10.mx-auto.text-center
          h1.display-4.fw-bold.mb-3
            i.bi.bi-lightning-charge.me-3
            | Fire and Forget for Enhanced Performance
          h2.h3.mb-4 Optimizing API Performance with Asynchronous Processing
          p.lead.mb-4
            | While working on a project, I encountered a practical challenge: how do I call an async method without waiting for it to process? The Fire and Forget pattern offers an elegant solution for enhancing API performance while maintaining system integrity.

      // GitHub Link Banner
      .row.mt-3
        .col-lg-8.mx-auto
          .alert.alert-primary.text-center
            i.bi.bi-github.me-2
            strong
              a.text-white(href='https://github.com/markhazleton/WebSpark.HttpClientUtility/' target="_blank" rel="noopener noreferrer" title='The full source code for the Fire and Forget Utility is available on GitHub') The full source code for the Fire and Forget Utility is available on GitHub

  // Main Article Content
  article#main-article
    .container
      .row
        .col-lg-9.mx-auto
          // Featured Image
          section#featured-image.mb-5.text-center
            img.img-fluid.rounded.shadow-lg(src="/assets/img/MarkHazleton-Fire-And-Forget.png" alt="Illustration representing fire-and-forget asynchronous programming for performance." title="Fire-and-Forget for Enhanced Performance" loading="lazy" width="800" height="450")

          // Table of Contents
          nav#table-of-contents.mb-5(aria-label='Table of Contents')
            .card.bg-light.shadow-sm
              .card-header
                h3.card-title.mb-0.fw-bold
                  i.bi.bi-list-ul.me-2
                  | Table of Contents
              .card-body
                ul.list-group.list-group-flush
                  li.list-group-item: a.text-decoration-none(href='#introduction') Introduction
                  li.list-group-item: a.text-decoration-none(href='#nuget-package') WebSpark.HttpClientUtility NuGet Package
                  li.list-group-item: a.text-decoration-none(href='#risks') The Risks of Not Waiting
                  li.list-group-item: a.text-decoration-none(href='#benefits') Benefits of Fire and Forget
                  li.list-group-item: a.text-decoration-none(href='#example') Example: Online Order Processing
                  li.list-group-item: a.text-decoration-none(href='#solution') Detailed Solution Breakdown

          // Introduction Section
          section#introduction.mb-5
            .card.shadow-sm.border-0
              .card-header.bg-primary.text-white
                h2.h3.mb-0
                  i.bi.bi-info-circle.me-2
                  | Introduction
              .card-body
                p.lead.mb-4
                  | Fire-and-forget is a programming approach where tasks are sent off to be processed independently, without the initiating program tracking or waiting for the results of these tasks.

                p.mb-0
                  | While working on a project, I encountered a practical challenge: how do I call an async method without waiting for it to process. I decided to explore the use of Fire and Forget technique in my AsyncSpark demo, which is now part of the
                  a(href='https://github.com/markhazleton/WebSpark.HttpClientUtility') WebSpark.HttpClientUtility
                  | library and NuGet package.

          // NuGet Package Section
          section#nuget-package.mb-5
            .card.shadow-sm.border-0
              .card-header.bg-success.text-white
                h2.h3.mb-0
                  i.bi.bi-box-seam.me-2
                  | Introducing the WebSpark.HttpClientUtility NuGet Package
              .card-body
                p.mb-4
                  | The Fire and Forget functionality is now part of the open-source
                  a.ms-1(href='https://github.com/markhazleton/WebSpark.HttpClientUtility' target='_blank') WebSpark.HttpClientUtility
                  |  library, available as a NuGet package for easy integration into your .NET projects.

                .alert.alert-light.border
                  h5.alert-heading
                    i.bi.bi-link-45deg.me-2
                    | Resources
                  ul.mb-0
                    li.mb-2
                      strong GitHub Repository:
                      a(href='https://github.com/markhazleton/WebSpark.HttpClientUtility' target='_blank') https://github.com/markhazleton/WebSpark.HttpClientUtility
                    li
                      strong NuGet Package:
                      a(href='https://www.nuget.org/packages/WebSpark.HttpClientUtility' target='_blank') WebSpark.HttpClientUtility

                p.mb-3
                  | To install the package, use the following command in your terminal:

                pre.language-powershell.bg-light.p-3.rounded
                  code.language-powershell Install-Package WebSpark.HttpClientUtility

                p.mb-0
                  | The library provides robust utilities for HTTP client operations, including the Fire and Forget pattern, with built-in exception handling and logging. This makes it easy to enhance your application's performance and reliability with minimal effort.

          // Risks Section
          section#risks.mb-5
            .card.shadow-sm.border-0
              .card-header.bg-danger.text-white
                h2.h3.mb-0
                  i.bi.bi-exclamation-triangle.me-2
                  | The Risks Of Not Waiting
              .card-body
                p.mb-4
                  | Fire-and-forget may call multiple methods without awaiting the completion of the methods.
                  | While this technique can be useful in certain scenarios, it can also lead to a number of issues, including:

                .card.mb-4.border-0.bg-light
                  .card-body
                    dl.mb-0
                      dt.d-flex.align-items-center.mb-2
                        i.bi.bi-bug.text-danger.me-2
                        | Unhandled Exceptions
                      dd.mb-3.ps-4 When a task is not awaited, exceptions thrown by it can lead to silent failures, making them difficult to catch and debug.

                      dt.d-flex.align-items-center.mb-2
                        i.bi.bi-cpu.text-danger.me-2
                        | Resource Management Issues
                      dd.mb-3.ps-4 Unawaited tasks may continue consuming resources, potentially leading to resource leaks or performance degradation, especially in high-load or long-running applications.

                      dt.d-flex.align-items-center.mb-2
                        i.bi.bi-arrow-repeat.text-danger.me-2
                        | Inconsistent Application State
                      dd.mb-3.ps-4 Not waiting for the completion of async operations can result in race conditions and unpredictable application behavior, affecting data integrity.

                      dt.d-flex.align-items-center.mb-2
                        i.bi.bi-hdd-network.text-danger.me-2
                        | I/O Operations and External System Interactions
                      dd.mb-0.ps-4 In scenarios involving I/O operations or external systems, unawaited tasks can result in incomplete or failed operations without appropriate notification or recovery mechanisms.

                p.mb-0
                  | The Fire and Forget pattern must be used with understanding of its risks and appropriate error handling mechanisms.
                  | In the context of my AsyncSpark demonstration in my WebSpark project, I decided to use the Fire and Forget pattern to update a Service Bus topic upon user login.
                  | This action, while important, is not directly tied to the user's immediate experience.
                  | In such cases, a delayed or inefficient handling can inadvertently hamper the API's responsiveness, leading to a suboptimal user experience.

          // Benefits Section
          section#benefits.mb-5
            .card.shadow-sm.border-0
              .card-header.bg-info.text-white
                h2.h3.mb-0
                  i.bi.bi-speedometer2.me-2
                  | Benefits Of Fire And Forget
              .card-body
                p.fw-bold.fs-5.mb-4
                  | Let's explore the use of Fire and Forget technique for improving API performance in tasks like Service Bus updates on user login.

                p.mb-3
                  | In today's fast-paced consumer driven world,
                  | API performance is vital for the user experience and business efficiency.
                  | One pattern that can be used is the "Fire and Forget" technique,
                  | particularly in scenarios where immediate response is key,
                  | but there are other tasks that are not critical to the user interaction.

                p.mb-3
                  | Take, for example, the process of updating a Service Bus topic upon user login. This action, while important, is not directly tied to the user's immediate experience. In such cases, a delayed or inefficient handling can inadvertently hamper the API's responsiveness, leading to a suboptimal user experience.

                p.mb-3
                  | This is where a well-designed Fire and Forget class comes into play. By effectively decoupling non-critical tasks from the main execution thread, we ensure that our API remains swift and responsive. This approach not only enhances performance but also elevates the user experience, a factor that's increasingly becoming a differentiator in the digital marketplace.

                p.mb-3
                  | Consider the scenario of a user logging into an application. Upon successful authentication, the system needs to update a Service Bus topic - an action that triggers other services to perform tasks like profile rebuilding or login history recording. While these tasks are important for maintaining system integrity and providing personalized experiences, they are not immediately critical to the user who is logging in.

                p.mb-3
                  | Implementing a Fire and Forget class in this context allows these non-urgent tasks to be handled asynchronously. This means the API can swiftly return a response to the user, confirming a successful login, while the system quietly takes care of the updates in the background. It's an elegant solution that balances the need for efficiency and thoroughness.

                p.mb-3
                  | Moreover, in a landscape where every millisecond counts, optimizing API performance with techniques like Fire and Forget is not just a technical consideration - it's a strategic one. By ensuring our systems are responsive and efficient, we're aligning technology more closely with business outcomes and user satisfaction.

                p.mb-0
                  | In summary, the Fire and Forget pattern is more than a technical solution; it's a strategic tool that can significantly enhance the performance and user experience of APIs. It's an approach that aligns well with my philosophy of practical, business-driven technology solutions - ensuring that we deliver not only in terms of technical performance but also in terms of tangible business value.

          // Example Section
          section#example.mb-5
            .card.shadow-sm.border-0
              .card-header.bg-primary.text-white
                h2.h3.mb-0
                  i.bi.bi-cart4.me-2
                  | Example: Online Order Processing
              .card-body
                p.mb-4
                  | Let's explore how the fire-and-forget pattern can be applied in a real-world scenario: online order processing. When a user places an order, immediate feedback is crucial for a good user experience. This is where our fire-and-forget method comes into play.

                .alert.alert-light.mb-4
                  h5.alert-heading
                    i.bi.bi-diagram-3.me-2
                    | Order Processing Flow
                  ol.mb-0
                    li.mb-2
                      strong Initial Confirmation:
                      | We start by sending a quick response to the user, confirming receipt of the order. This is the 'fire' part. It's fast and gives immediate feedback.
                    li.mb-2
                      strong Background Processing:
                      | Behind the scenes, the system then processes several sub-tasks like validating the order, checking inventory, and calculating shipping. This is done asynchronously, without the user having to wait for each step to complete.
                    li.mb-2
                      strong User Experience:
                      | The user can continue with other activities, while our system handles these tasks in the background.
                    li
                      strong Final Notification:
                      | Once all sub-tasks are complete, the system sends a detailed confirmation to the user. This might take a few minutes, but it doesn't hinder the user's experience as they have already moved on after the initial confirmation.

                p.mb-4
                  | Here are tasks that might be involved in the processing of an online order,
                  | both from a customer-facing and a back-end perspective.
                  | Some of these tasks are critical to the user experience, while others are not.
                  | The fire-and-forget pattern can be used to handle the non-critical tasks,
                  | ensuring that the user gets a swift response while the system quietly takes care of the rest.

                .row
                  .col-md-6
                    .card.mb-3.h-100.border-0.bg-light
                      .card-header.bg-secondary.text-white User-Facing Tasks
                      .card-body
                        dl.mb-0
                          dt
                            i.bi.bi-box.text-primary.me-2
                            | Inventory Check
                          dd.mb-3 Ensuring the ordered items are in stock.

                          dt
                            i.bi.bi-shield-check.text-primary.me-2
                            | Fraud Analysis
                          dd.mb-3 Assessing the order for potential fraud or security risks.

                          dt
                            i.bi.bi-tag.text-primary.me-2
                            | Shipping Label Creation
                          dd Generating a shipping label with tracking information.

                  .col-md-6
                    .card.mb-3.h-100.border-0.bg-light
                      .card-header.bg-secondary.text-white Backend Tasks
                      .card-body
                        dl.mb-0
                          dt
                            i.bi.bi-gear.text-primary.me-2
                            | Automatic Reorder of Stock
                          dd.mb-3 Initiating a reorder if inventory levels are low.

                          dt
                            i.bi.bi-building.text-primary.me-2
                            | Warehouse Management
                          dd.mb-3 Updating the warehouse system with order details.

                          dt
                            i.bi.bi-database.text-primary.me-2
                            | Data Analysis and Reporting
                          dd Updating and analyzing sales and inventory data.

          // Solution Section
          section#solution.mb-5
            .card.shadow-sm.border-0
              .card-header.bg-success.text-white
                h2.h3.mb-0
                  i.bi.bi-code-square.me-2
                  | Detailed Solution Breakdown
              .card-body
                .card.mb-4.border-0.bg-light
                  .card-body
                    dl.mb-0
                      dt.d-flex.align-items-center.mb-2
                        i.bi.bi-file-earmark-code.text-success.me-2
                        | Class Definition
                      dd.mb-3.ps-4
                        | The `FireAndForgetUtility` class is a sealed class designed for asynchronous operations without requiring a response,
                        | incorporating exception handling and logging. In C# and other .NET languages, a 'sealed' class is a class that cannot
                        | be inherited by other classes. It's a way to prevent further inheritance and is often used to provide a guarantee
                        | that the class's behavior won't be altered unexpectedly by a subclass.
                        | Once a class is declared as 'sealed', it's a final class and cannot serve as a base class for any other class.

                      dt.d-flex.align-items-center.mb-2
                        i.bi.bi-journal-code.text-success.me-2
                        | Constructor and Logger
                      dd.mb-3.ps-4 It takes an `ILogger` object in the constructor and initializes a private readonly `_logger` field. The logger is crucial for tracking the behavior and exceptions of the tasks.

                      dt.d-flex.align-items-center.mb-2
                        i.bi.bi-lightning.text-success.me-2
                        | Method: SafeFireAndForget
                      dd.mb-3.ps-4 The `SafeFireAndForget` method accepts a `Task` and an optional `CancellationToken`. It ensures that the provided task is not null before proceeding.

                      dt.d-flex.align-items-center.mb-2
                        i.bi.bi-arrow-right.text-success.me-2
                        | Task Continuation
                      dd.mb-3.ps-4 The method uses `ContinueWith` to handle the task's completion. Depending on the task's state (faulted, canceled, or successfully completed), it logs appropriate messages.

                      dt.d-flex.align-items-center.mb-2
                        i.bi.bi-exclamation-circle.text-success.me-2
                        | Exception Handling
                      dd.mb-3.ps-4 In case of exceptions, it iterates through all inner exceptions (if any) and logs them, ensuring thorough reporting of issues.

                      dt.d-flex.align-items-center.mb-2
                        i.bi.bi-x-circle.text-success.me-2
                        | Cancellation Handling
                      dd.mb-3.ps-4 The method also handles task cancellation scenarios, logging a message if the task is canceled or if the cancellation token is requested.

                      dt.d-flex.align-items-center.mb-2
                        i.bi.bi-check-circle.text-success.me-2
                        | Conclusion
                      dd.ps-4 This utility class is a robust tool for handling tasks that don't require direct synchronization with the main execution flow, enhancing application performance and responsiveness.

                // Code Example with Collapse
                .mb-3
                  button.btn.btn-primary.mb-2(type='button', data-bs-toggle='collapse', data-bs-target='#fireAndForgetCode')
                    i.bi.bi-code-slash.me-2
                    | Show/Hide Code Example

                  .collapse#fireAndForgetCode
                    pre.language-csharp.bg-dark.text-white.p-3.rounded
                      code.language-csharp.
                        public sealed class FireAndForgetUtility
                        {
                            private readonly ILogger _logger;

                            public FireAndForgetUtility(ILogger logger)
                            {
                                _logger = logger;
                            }

                            public void SafeFireAndForget(Task task, CancellationToken cancellationToken = default)
                            {
                                if (task == null)
                                {
                                    throw new ArgumentNullException(nameof(task));
                                }

                                task.ContinueWith(t =>
                                {
                                    if (t.IsFaulted)
                                    {
                                        LogExceptions(t.Exception);
                                    }
                                    else if (t.IsCanceled)
                                    {
                                        _logger.LogInformation("Task canceled");
                                    }
                                    else
                                    {
                                        _logger.LogInformation("Task completed");
                                    }
                                }, cancellationToken);
                            }

                            private void LogExceptions(Exception exception)
                            {
                                _logger.LogError(exception, "Exception in task");

                                if (exception is AggregateException aggregateException)
                                {
                                    foreach (var innerException in aggregateException.InnerExceptions)
                                    {
                                        LogExceptions(innerException);
                                    }
                                }
                            }
                        }

          // Back to top button
          .text-center.mt-5.mb-3
            a.btn.btn-primary(href='#table-of-contents')
              i.bi.bi-arrow-up-circle.me-2
              | Back to Table of Contents

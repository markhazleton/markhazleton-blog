extends ../layouts/articles

block pagehead
  title Development - Fire and Forget for Enhanced Performance
  meta(name='author', content='Mark Hazleton')
  meta(name="description", content="Explore the use of Fire and Forget technique for improving API performance in tasks like Service Bus updates on user login.")
  meta(name="keywords", content="Mark Hazleton, API Performance, Fire and Forget, Asynchronous Processing, Service Bus, User Experience, Technology Solutions, System Integrity, Software Architecture")
  link(rel='canonical', href='https://markhazleton.com/articles/fire-and-forget-for-enhanced-performance.html')
  //- Open Graph tags
  meta(property="og:title" content="Development - Fire and Forget for Enhanced Performance")
  meta(property="og:description" content="Explore the use of Fire and Forget technique for improving API performance in tasks like Service Bus updates on user login.")
  meta(property="og:url" content="https://markhazleton.com/articles/fire-and-forget-for-enhanced-performance.html")
  meta(property="og:type" content="article")
  meta(property="og:image" content="/assets/img/MarkHazleton-Fire-And-Forget.png")
  //- Twitter Card data
  meta(name="twitter:card" content="summary_large_image")
  meta(name="twitter:title" content="Development - Fire and Forget for Enhanced Performance")
  meta(name="twitter:description" content="Explore the use of Fire and Forget technique for improving API performance in tasks like Service Bus updates on user login.")
  meta(name="twitter:image" content="/assets/img/MarkHazleton-MarkHazleton-Fire-And-Forget.png")
  //- Additional tags
  meta(name="robots" content="index, follow")
  meta(name="language" content="English")
  meta(name="revisit-after" content="7 days")


block layout-content

  section#post.painteddesert-section.painteddesert-section-background
    .painteddesert-section-content
      h1 Fire and Forget
      p.card-text.lead.mb-5
          | While working on a project, I encountered a practical challenge: how do I call an async method without waiting for it to process.
          | I decided to explore the use of Fire and Forget technique in my AsyncDemo project.
          a(href='https://github.com/markhazleton/AsyncDemo') https://github.com/markhazleton/AsyncDemo
          | .
          | Fire-and-forget is a programming approach where tasks are sent off to be processed independently,
          | without the initiating program tracking or waiting for the results of these tasks.

      h2 The Risks Of Not Waiting
      p.
        Fire-and-forget may call multiple methods without awaiting the completion of the methods.
        While this technique can be useful in certain scenarios, it can also lead to a number of issues, including:
      dl
        dt Unhandled Exceptions
        dd When a task is not awaited, exceptions thrown by it can lead to silent failures, making them difficult to catch and debug.
        dt Resource Management Issues
        dd Unawaited tasks may continue consuming resources, potentially leading to resource leaks or performance degradation, especially in high-load or long-running applications.
        dt Inconsistent Application State
        dd Not waiting for the completion of async operations can result in race conditions and unpredictable application behavior, affecting data integrity.
        dt I/O Operations and External System Interactions
        dd In scenarios involving I/O operations or external systems, unawaited tasks can result in incomplete or failed operations without appropriate notification or recovery mechanisms.
      p.
          The Fire and Forget pattern must be used with understanding of its risks and appropriate error handling mechanisms.
          In the context of my AsyncDemo project, I decided to use the Fire and Forget pattern to update a Service Bus topic upon user login.
          This action, while important, is not directly tied to the user's immediate experience.
          In such cases, a delayed or inefficient handling can inadvertently hamper the API's responsiveness, leading to a suboptimal user experience.

      h2 Benefits Of Fire And Forget
      strong.lead Let`s Explore the use of Fire and Forget technique for improving API performance in tasks like Service Bus updates on user login.
      p.
       In today's fast-paced consumer driven world,
       API performance is vital for the user experience and business efficiency.
       One pattern that can be used is the "Fire and Forget" technique,
       particularly in scenarios where immediate response is key,
       but their are other tasks that are not critical to the user interaction.
      p Take, for example, the process of updating a Service Bus topic upon user login. This action, while important, is not directly tied to the user's immediate experience. In such cases, a delayed or inefficient handling can inadvertently hamper the API's responsiveness, leading to a suboptimal user experience.
      p This is where a well-designed Fire and Forget class comes into play. By effectively decoupling non-critical tasks from the main execution thread, we ensure that our API remains swift and responsive. This approach not only enhances performance but also elevates the user experience, a factor that's increasingly becoming a differentiator in the digital marketplace.
      p Consider the scenario of a user logging into an application. Upon successful authentication, the system needs to update a Service Bus topic - an action that triggers other services to perform tasks like profile rebuilding or login history recording. While these tasks are important for maintaining system integrity and providing personalized experiences, they are not immediately critical to the user who is logging in.
      p Implementing a Fire and Forget class in this context allows these non-urgent tasks to be handled asynchronously. This means the API can swiftly return a response to the user, confirming a successful login, while the system quietly takes care of the updates in the background. It's an elegant solution that balances the need for efficiency and thoroughness.
      p Moreover, in a landscape where every millisecond counts, optimizing API performance with techniques like Fire and Forget is not just a technical consideration - it's a strategic one. By ensuring our systems are responsive and efficient, we're aligning technology more closely with business outcomes and user satisfaction.
      p In summary, the Fire and Forget pattern is more than a technical solution; it's a strategic tool that can significantly enhance the performance and user experience of APIs. It's an approach that aligns well with my philosophy of practical, business-driven technology solutions - ensuring that we deliver not only in terms of technical performance but also in terms of tangible business value.

      div.card.w-50.mx-auto.mb-5
        div.card-header
          h5.card-title Example: Online Order Processing
        div.card-body
          p Let`s explore how the fire-and-forget pattern can be applied in a real-world scenario: online order processing. When a user places an order, immediate feedback is crucial for a good user experience. This is where our fire-and-forget method comes into play.
          p We start by sending a quick response to the user, confirming receipt of the order. This is the 'fire' part. It's fast and gives immediate feedback.
          p Behind the scenes, the system then processes several sub-tasks like validating the order, checking inventory, and calculating shipping. This is done asynchronously, without the user having to wait for each step to complete. The user can continue with other activities, while our system handles these tasks in the background.
          p Finally, once all sub-tasks are complete, the system sends a detailed confirmation to the user. This might take a few minutes, but it doesn't hinder the user's experience as they have already moved on after the initial confirmation.
          p.
            Here are tasks that might be involved in the processing of an online order,
            both from a customer-facing and a back-end perspective.
            Some of these tasks are critical to the user experience, while others are not.
            The fire-and-forget pattern can be used to handle the non-critical tasks,
            ensuring that the user gets a swift response while the system quietly takes care of the rest.
          dl
            dt Inventory Check
            dd Ensuring the ordered items are in stock.
            dt Fraud Analysis
            dd Assessing the order for potential fraud or security risks. Running fraud detection analysis on the order details.
            dt Picking and Packing
            dd Preparing the items in the warehouse for shipment.
            dt Shipping Label Creation
            dd Generating a shipping label with tracking information.
            dt Automatic Reorder of Stock
            dd Initiating a reorder if inventory levels are low.
            dt Order Routing
            dd Deciding the fulfillment center based on various factors.
            dt Supplier Notification
            dd Notifying suppliers for direct shipping or inventory replenishment.
            dt Warehouse Management
            dd Updating the warehouse system with order details.
            dt Logistics Coordination
            dd Coordinating with shipping partners for order delivery.
            dt Data Analysis and Reporting
            dd Updating and analyzing sales and inventory data.
            dt CRM Update
            dd Recording order details in the CRM system for future reference.

        div.card-footer
          p.card-text


      h2 Detailed Solution Breakdown
      dl
        dt Class Definition
        dd.
         The `FireAndForgetUtility` class is a sealed class designed for asynchronous operations without requiring a response,
         incorporating exception handling and logging. In C# and other .NET languages, a 'sealed' class is a class that cannot
         be inherited by other classes. It's a way to prevent further inheritance and is often used to provide a guarantee
         that the class's behavior won't be altered unexpectedly by a subclass.
         Once a class is declared as 'sealed', it's a final class and cannot serve as a base class for any other class.
        dt Constructor and Logger
        dd It takes an `ILogger` object in the constructor and initializes a private readonly `_logger` field. The logger is crucial for tracking the behavior and exceptions of the tasks.
        dt Method: SafeFireAndForget
        dd The `SafeFireAndForget` method accepts a `Task` and an optional `CancellationToken`. It ensures that the provided task is not null before proceeding.
        dt Task Continuation
        dd The method uses `ContinueWith` to handle the task's completion. Depending on the task's state (faulted, canceled, or successfully completed), it logs appropriate messages.
        dt Exception Handling
        dd In case of exceptions, it iterates through all inner exceptions (if any) and logs them, ensuring thorough reporting of issues.
        dt Cancellation Handling
        dd The method also handles task cancellation scenarios, logging a message if the task is canceled or if the cancellation token is requested.
        dt Conclusion
        dd This utility class is a robust tool for handling tasks that don't require direct synchronization with the main execution flow, enhancing application performance and responsiveness.
      pre.code
        code
          | public sealed class FireAndForgetUtility
          | {
          |     private readonly ILogger _logger;
          |
          |     public FireAndForgetUtility(ILogger logger)
          |     {
          |         _logger = logger;
          |     }
          |
          |     public void SafeFireAndForget(Task task, CancellationToken cancellationToken = default)
          |     {
          |         if (task == null)
          |         {
          |             throw new ArgumentNullException(nameof(task));
          |         }
          |
          |         task.ContinueWith(t =>
          |         {
          |             if (t.IsFaulted)
          |             {
          |                 LogExceptions(t.Exception);
          |             }
          |             else if (t.IsCanceled)
          |             {
          |                 _logger.LogInformation("Task canceled");
          |             }
          |             else
          |             {
          |                 _logger.LogInformation("Task completed");
          |             }
          |         }, cancellationToken);
          |     }
          |
          |     private void LogExceptions(Exception exception)
          |     {
          |         _logger.LogError(exception, "Exception in task");
          |
          |         if (exception is AggregateException aggregateException)
          |         {
          |             foreach (var innerException in aggregateException.InnerExceptions)
          |             {
          |                 LogExceptions(innerException);
          |             }
          |         }
          |     }
          | }

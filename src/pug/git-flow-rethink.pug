extends layouts/layout

block pagehead
  title Mark Hazleton - Git Flow Rethink
  meta(name='description', content='Mark Hazleton - Git Flow Rethink')
  meta(name='author', content='Mark Hazleton')
  link(rel='canonical', href='https://markhazleton.controlorigins.com/git-flow-rethink.html')

block layout-content

  section#post.painteddesert-section.painteddesert-section-background
    .painteddesert-section-content
      h1.mb-0 Git Flow Rethink
      .subheading.mb-3 Revaluating the meaning of Continuous in CI/CD

      h2.mb-3 Git Flow Experience
      p.
        As developers, we've spent years honing our craft and embracing the Git Flow
        branching methodology. It's served us well, providing structure and clarity in our version control
        and collaboration efforts.
        But here's the rub: the world of software development and DevOps is
        evolving faster than ever. How can we keep up with these changes?
        Rather than throwing the baby out with the bathwater and starting from scratch,
        what if we could take what we've learned from years of Git Flow and evolve it
        to harness the power of the current DevOps tools at our disposal?
      p.
        Let us embark on a journey of continuous improvement, seeking to enhance our processes
        without abandoning the foundation we've built.
        We'll explore how the landscape of software development has transformed and recognize that
        the primary concerns addressed by Git Flow may not be as prevalent today.
        There is a way to adapt and evolve our practices to
        embrace the efficiencies provided by modern DevOps tools.
      p.
        By embracing the concept of continuous integration and deployment,
        we can simplify our workflows while maintaining the necessary quality assurance measures.
        It's a balancing act of taking the best of Git Flow and integrating it with the power of modern tooling.



      div.card
        div.card-header
          h3.mb-3 Git Flow Recap
        div.card-body
          p.
            The Git Flow branching methodology, created by Vincent Driessen and popularized through his blog post
            titled  <a href='https://nvie.com/posts/a-successful-git-branching-model/' target="_blank">"A successful Git branching model"</a>,
            has been widely adopted by software development shops
            as the formal way to manage changes. Its structured approach provided a clear workflow for version control
            and collaboration. It has served me well as my go-to branching model for many years.  But as we embrace
            the power of continuous integration and deployment, some of the aspects of Git Flow seem to introduce unnecessary
            ceremony into the development process.
          p.
            In a recent update to the original blog post, Vincent Driessen states:
          blockquote If your team is doing continuous delivery of software, I would suggest adopting a much simpler workflow instead of trying to shoehorn git-flow into your team.

      p.
        After using the model for years, I took a step back and had to ask if git-flow was the best branching model for my team.
        Or was I following it because it was the way I had always done it?   In many projects, I found
        that I did not need much of the ceremony of Git Flow. On my projects,
        we did not have multiple teams working in the same
        repository on features that spanned multiple iterations.
        Web applications that continuously improve, did not need the
        rigor or ability to quickly restore older product versions.
      p.
        After many discussions on the merits of Git Flow, particularly the use of permanent development
        and main branches and branch creation for each release with a merge back into both develop and main branches
        has created tasks that seem to add more form than substance.
        The DevOps tooling does not support the Git Flow branching model out of the box, requiring manual intervention
        and enforcement via processes and procedures.  This manual intervention can lead to inconsistencies.
      dl
        dt Branch Policies and Protection
        dd
          p.
            In the Git Flow branching model, temporary branches such as release and hotfix branches
            play a crucial role in managing specific features or addressing critical issues.
            However, implementing branch policies on these temporary branches can pose challenges,
            particularly in certain DevOps platforms like Azure DevOps.
            The difficulty arises from the manual application of default
            and comparing branch attributes
            to each new branch, which can result in release and hotfix branches lacking the same level
            of protection as permanent branches.
        dt What is in Production?
        dd
          p.
            One of the challenges with the traditional Git Flow branching model is determining what
            exactly is in production by simply looking at the repository.
            In Git Flow, temporary branches are often created for releases and hotfixes,
            which are subsequently merged back into the development and main branches.
            However, in many cases, the release or hotfix branch remains open after deployment,
            allowing for quick fixes if necessary.
            This practice can make it difficult to identify the exact state of the production environment
            by examining the repository alone.
          p.
            The ambiguity surrounding what is in production becomes a concern,
            particularly when trying to trace back specific changes or identify the codebase associated
            with a particular release. Without clear indicators or references, developers
            and team members may find it challenging to pinpoint the exact code deployed
            in the production environment.
            This lack of visibility can hinder troubleshooting efforts and make it harder to establish
            a comprehensive understanding of the software's state.

        dt False Sense of Security
        dd
          p.
            The Git Flow branching model's reliance on two branches, develop and main,
            can lead to a false sense of security.
            In this model, any commit merged into the develop branch will become part
            of main branch and production.
            However, this means that the develop branch requires the same level of control
            and scrutiny as the main branch.
            Unfortunately, the develop branch often becomes a temporary workspace for ongoing development,
            making it susceptible to inconsistencies and lax code quality controls.
            Additionally, the lack of branch policies on temporary branches complicates
            maintaining code integrity throughout the development process.

      h2.mb-3 A Single Permanent Branch
      p.
        In response to the limitations and challenges posed by Git Flow,
        an alternative approach gaining momentum is the adoption of a single-branch strategy.
        This approach involves using a single branch for all pull requests, streamlining the development process
        and simplifying the codebase management.
        But how can this single-branch approach overcome the weaknesses of Git Flow and ensure efficient
        and controlled development?
      p.
        The answer lies in leveraging the power of modern DevOps tooling.
        The tooling available today provides robust features and automation capabilities that can
        offset the manual processes and policies traditionally required in Git Flow.
        Let's explore how these tools can address the weaknesses and enhance the efficiency
        of the single-branch approach.
      dl
        dt Automated branch policies
        dd
          p.
            DevOps platforms such as Azure DevOps, GitHub, and GitLab offer automated branch policies.
            These policies can be easily configured to enforce code reviews, unit tests,
            and other quality checks for every pull request.
            By configuring these policies on your permanent branch,
            developers can focus on coding while the tooling ensures the
            necessary quality assurance measures are in place.
        dt Continuous Integration and Deployment (CI/CD) pipelines
        dd
          p.
            Modern CI/CD pipelines provide seamless integration with version control systems.
            They can be configured to trigger automated builds, tests, and deployments
            for every pull request and merge into a single branch.
            This ensures that code changes are continuously integrated, validated, and deployed to development
            , staging, and ultimately production environments, enabling rapid feedback loops and early identification
            of issues.
        dt Versioning
        dd
          p.
            You can configure your project to increment the version upon every build.
            This means you can
            look at the assemblies and easily know when they were built and what version they are.
            This is a huge
            benefit when trying to determine what is in production.
            With a single-branch approach, the tooling can facilitate automated versioning, tagging,
            and release creation based on specific commits within the single branch.
            This simplifies the process of identifying what is in production and enables teams to track
            and manage releases more effectively.
      p.
        By embracing the single-branch approach and utilizing the advanced tooling available,
        we can optimize our development processes and mitigate the
        weaknesses associated with Git Flow. The automated branch policies, CI/CD pipelines,
        and release management features empower teams to enforce quality controls,
        ensure continuous integration and deployment, and streamline the identification of code in production.
      p.
        The reliance on manual processes and policies in Git Flow can be
        significantly reduced.
        This enables developers to focus on delivering value more rapidly without sacrificing code quality.
        By leveraging the advancements in DevOps tooling, the single-branch approach becomes a powerful
        strategy for efficient and controlled software development, ultimately leading to
        improved productivity and software delivery.
      p.
        This rethink of the Git Flow branching model opens up new possibilities for teams to innovate, collaborate,
        and accelerate their development processes. It liberates developers from unnecessary complexities and allows
        them to concentrate on what truly matters—building great software.


extends layouts/modern-layout

block layout-content
  // Breadcrumb Navigation
  .container.mt-4
    nav.breadcrumb-modern(aria-label='breadcrumb')
      ol.breadcrumb
        li.breadcrumb-item
          a.text-decoration-none(href='/') Home
        li.breadcrumb-item
          a.text-decoration-none(href='/articles.html') Articles
        li.breadcrumb-item.active(aria-current='page') Concurrent Processing

  // Article Content
  article#main-article.py-5
    .container
      .row
        .col-lg-8.mx-auto
          header.mb-5
            .alert.alert-info.text-center.mb-4
              i.bi.bi-github.me-2
              a.text-decoration-none.fw-bold(href='https://github.com/markhazleton/concurrentprocessing/', target='_blank', rel='noopener')
                | View the complete source code on GitHub
                i.bi.bi-box-arrow-up-ne.ms-1

            h1.display-4.fw-bold#top Concurrent Processing in C#
            .subheading.h4.text-muted.mb-4 Learning Concurrent Processing Through Code
            .article-meta.text-muted.mb-4
              time(datetime=publishedDate) #{new Date(publishedDate).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}
              span.mx-2 •
              span by Mark Hazleton
              span.mx-2 •
              span #{estimatedReadTime} min read

          .article-content
            p.lead.
              As a developer, one of the most exciting aspects of programming is the
              opportunity to learn new concepts and techniques.
              Recently, I embarked on a journey to understand concurrent processing better,
              and I'm excited to share my experience with you.

            p.mb-4.
              The idea of managing multiple tasks simultaneously has always fascinated me.
              However, it can be a complex challenge, requiring synchronization
              and careful management to avoid issues like race conditions and deadlocks.
              To dive into this topic, I decided to develop a C# console application
              that would allow me to experiment and learn practically.

            section.mb-5
              h2.h3.mb-4
                i.bi.bi-list-check.me-2.text-primary
                | Considerations for Concurrent Processing

              .accordion#considerationsAccordion
                .accordion-item
                  h3.accordion-header#headingAutonomy
                    button.accordion-button.collapsed(
                      type='button'
                      data-bs-toggle='collapse'
                      data-bs-target='#collapseAutonomy'
                      aria-expanded='false'
                      aria-controls='collapseAutonomy'
                    )
                      i.bi.bi-gear.me-2.text-success
                      | Task Autonomy and Independence
                  .accordion-collapse.collapse#collapseAutonomy(
                    aria-labelledby='headingAutonomy'
                    data-bs-parent='#considerationsAccordion'
                  )
                    .accordion-body
                      p.
                        For multiple tasks to effectively run concurrently, each task must encapsulate an autonomous and self-contained unit of functionality. Autonomy ensures that a task operates independently, free from unnecessary dependencies on other tasks or shared resources.

                .accordion-item
                  h3.accordion-header#headingSynchronization
                    button.accordion-button.collapsed(
                      type='button'
                      data-bs-toggle='collapse'
                      data-bs-target='#collapseSynchronization'
                      aria-expanded='false'
                      aria-controls='collapseSynchronization'
                    )
                      i.bi.bi-arrow-repeat.me-2.text-primary
                      | Synchronization
                  .accordion-collapse.collapse#collapseSynchronization(
                    aria-labelledby='headingSynchronization'
                    data-bs-parent='#considerationsAccordion'
                  )
                    .accordion-body
                      p.
                        Ensuring proper synchronization is crucial to prevent race conditions and ensure data consistency among multiple threads or tasks. Techniques like locks, semaphores, and monitors can be used to control access to shared resources.

                .accordion-item
                  h3.accordion-header#headingScalability
                    button.accordion-button.collapsed(
                      type='button'
                      data-bs-toggle='collapse'
                      data-bs-target='#collapseScalability'
                      aria-expanded='false'
                      aria-controls='collapseScalability'
                    )
                      i.bi.bi-bar-chart.me-2.text-info
                      | Scalability
                  .accordion-collapse.collapse#collapseScalability(
                    aria-labelledby='headingScalability'
                    data-bs-parent='#considerationsAccordion'
                  )
                    .accordion-body
                      p.
                        Consider the scalability of your concurrent processing solution. Will it perform well as the number of concurrent tasks or threads increases? Design your system to handle increased load without degrading performance.

                .accordion-item
                  h3.accordion-header#headingDeadlocks
                    button.accordion-button.collapsed(
                      type='button'
                      data-bs-toggle='collapse'
                      data-bs-target='#collapseDeadlocks'
                      aria-expanded='false'
                      aria-controls='collapseDeadlocks'
                    )
                      i.bi.bi-exclamation-triangle.me-2.text-warning
                      | Deadlocks and Livelocks
                  .accordion-collapse.collapse#collapseDeadlocks(
                    aria-labelledby='headingDeadlocks'
                    data-bs-parent='#considerationsAccordion'
                  )
                    .accordion-body
                      p.
                        Be aware of potential deadlocks and livelocks that can occur when multiple threads are waiting for resources that are held by other threads. Avoid circular dependencies and ensure proper resource allocation/release.

                .accordion-item
                  h3.accordion-header#headingResourceManagement
                    button.accordion-button.collapsed(
                      type='button'
                      data-bs-toggle='collapse'
                      data-bs-target='#collapseResourceManagement'
                      aria-expanded='false'
                      aria-controls='collapseResourceManagement'
                    )
                      i.bi.bi-memory.me-2.text-secondary
                      | Resource Management
                  .accordion-collapse.collapse#collapseResourceManagement(
                    aria-labelledby='headingResourceManagement'
                    data-bs-parent='#considerationsAccordion'
                  )
                    .accordion-body
                      p.
                        Properly manage resources such as memory, file handles, and network connections. Failing to release resources can lead to resource exhaustion and degrade system performance.

                .accordion-item
                  h3.accordion-header#headingThreadSafety
                    button.accordion-button.collapsed(
                      type='button'
                      data-bs-toggle='collapse'
                      data-bs-target='#collapseThreadSafety'
                      aria-expanded='false'
                      aria-controls='collapseThreadSafety'
                    )
                      i.bi.bi-shield-check.me-2.text-success
                      | Thread Safety
                  .accordion-collapse.collapse#collapseThreadSafety(
                    aria-labelledby='headingThreadSafety'
                    data-bs-parent='#considerationsAccordion'
                  )
                    .accordion-body
                      p.
                        Ensure that your code is thread-safe. Thread safety means that the behavior of a program remains consistent when multiple threads are executing simultaneously. Use techniques like immutable data, synchronization, and thread-local storage.

                .accordion-item
                  h3.accordion-header#headingLoadBalancing
                    button.accordion-button.collapsed(
                      type='button'
                      data-bs-toggle='collapse'
                      data-bs-target='#collapseLoadBalancing'
                      aria-expanded='false'
                      aria-controls='collapseLoadBalancing'
                    )
                      i.bi.bi-diagram-3.me-2.text-primary
                      | Load Balancing
                  .accordion-collapse.collapse#collapseLoadBalancing(
                    aria-labelledby='headingLoadBalancing'
                    data-bs-parent='#considerationsAccordion'
                  )
                    .accordion-body
                      p.
                        Distribute tasks evenly among threads or processing units to ensure efficient utilization of resources. Load balancing helps prevent scenarios where some threads are idle while others are overloaded.

                .accordion-item
                  h3.accordion-header#headingTaskGranularity
                    button.accordion-button.collapsed(
                      type='button'
                      data-bs-toggle='collapse'
                      data-bs-target='#collapseTaskGranularity'
                      aria-expanded='false'
                      aria-controls='collapseTaskGranularity'
                    )
                      i.bi.bi-puzzle.me-2.text-info
                      | Task Granularity
                  .accordion-collapse.collapse#collapseTaskGranularity(
                    aria-labelledby='headingTaskGranularity'
                    data-bs-parent='#considerationsAccordion'
                  )
                    .accordion-body
                      p.
                        Determine the appropriate level of task granularity. Too fine-grained tasks can lead to overhead due to thread management, while too coarse-grained tasks might not fully utilize available resources.

                .accordion-item
                  h3.accordion-header#headingErrorHandling
                    button.accordion-button.collapsed(
                      type='button'
                      data-bs-toggle='collapse'
                      data-bs-target='#collapseErrorHandling'
                      aria-expanded='false'
                      aria-controls='collapseErrorHandling'
                    )
                      i.bi.bi-bug.me-2.text-danger
                      | Error Handling
                  .accordion-collapse.collapse#collapseErrorHandling(
                    aria-labelledby='headingErrorHandling'
                    data-bs-parent='#considerationsAccordion'
                  )
                    .accordion-body
                      p.
                        Implement robust error-handling mechanisms for concurrent tasks. Unhandled exceptions in one task should not crash the entire application.

                .accordion-item
                  h3.accordion-header#headingTesting
                    button.accordion-button.collapsed(
                      type='button'
                      data-bs-toggle='collapse'
                      data-bs-target='#collapseTesting'
                      aria-expanded='false'
                      aria-controls='collapseTesting'
                    )
                      i.bi.bi-search.me-2.text-secondary
                      | Testing and Debugging
                  .accordion-collapse.collapse#collapseTesting(
                    aria-labelledby='headingTesting'
                    data-bs-parent='#considerationsAccordion'
                  )
                    .accordion-body
                      p.
                        Testing concurrent code is challenging. Consider using techniques like stress testing and race condition detection tools to identify issues. Debugging concurrent issues can be complex.

                .accordion-item
                  h3.accordion-header#headingCommunication
                    button.accordion-button.collapsed(
                      type='button'
                      data-bs-toggle='collapse'
                      data-bs-target='#collapseCommunication'
                      aria-expanded='false'
                      aria-controls='collapseCommunication'
                    )
                      i.bi.bi-chat-dots.me-2.text-primary
                      | Communication and Coordination
                  .accordion-collapse.collapse#collapseCommunication(
                    aria-labelledby='headingCommunication'
                    data-bs-parent='#considerationsAccordion'
                  )
                    .accordion-body
                      p.
                        Threads or tasks might need to communicate and coordinate with each other. Consider using mechanisms like message queues, shared memory, and events to facilitate inter-thread communication.

            section.mb-5
              h2.h3.mb-4
                i.bi.bi-exclamation-circle.me-2.text-warning
                | Potential Drawbacks in Concurrent Programming

              .alert.alert-warning.mb-4
                h5.alert-heading
                  i.bi.bi-info-circle.me-2
                  | Challenges to Consider
                p.mb-2 While concurrent programming boosts performance and resource utilization, it comes with challenges:
                ul.mb-0
                  li Risk of Deadlocks and Livelocks
                  li Difficulty in Debugging and Testing
                  li Potential for Race Conditions
                  li Increased Memory Consumption
                  li Complexity in Code Management and Maintenance

              p.mb-4 By understanding these challenges, developers can employ strategies to mitigate risks and harness the benefits of concurrency in their projects.

            section.mb-5
              h2.h3.mb-4
                i.bi.bi-code-slash.me-2.text-primary
                | Building the Concurrent Processing Demo

              p.mb-4
                | Since this was a one-off project, I didn't want to spend too much time on the user interface. I created a repository to create a simple console application that would allow me to focus on the core functionality.
                a.text-decoration-none(href='https://github.com/markhazleton/ConcurrentProcessing', target='_blank', rel='noopener')
                  | View the Concurrent Processing C# Project on GitHub
                  i.bi.bi-box-arrow-up-ne.ms-1

              p.mb-4 I started with a ChatGPT prompt that introduced me to the basics of concurrent processing. Armed with this initial guidance, I started writing the code. Before long I had the basic scaffolding in place, and I was ready to start iterating and learning.

              p.mb-3
                | Check out the
                a.text-decoration-none(href='#SemaphoreSlimClass') SemaphoreSlim Class section
                |  for more details.

              .card.shadow-sm.mb-4
                .card-header.bg-primary.text-white
                  h5.mb-0
                    i.bi.bi-code-slash.me-2
                    | Core Concurrent Processing Logic
                .card-body
                  pre.language-csharp.mb-0
                    code.language-csharp.
                      const int maxConcurrency = 100; // Maximum concurrent tasks allowed
                      SemaphoreSlim semaphore = new(maxConcurrency);
                      List<Task> tasks = new();
                      int? taskId = 0;
                      while (taskId is not null)
                      {
                        Task task = ProcessAsync(taskId.Value, tasks.Count, await AwaitSemaphoreAsync(semaphore), semaphore);
                        tasks.Add(task);
                        taskId = GetNextTaskId(taskId);

                        if (tasks.Count >= maxConcurrency)
                        {
                          Task finishedTask = await Task.WhenAny(tasks);
                          tasks.Remove(finishedTask);
                        }
                      }
                      await Task.WhenAll(tasks);

              p.mb-4 I created a function to wait for a semaphore to be released and added some telemetry to track the time spent waiting.

              .card.shadow-sm.mb-4
                .card-header.bg-secondary.text-white
                  h5.mb-0
                    i.bi.bi-stopwatch.me-2
                    | Semaphore Wait Function
                .card-body
                  pre.language-csharp.mb-0
                    code.language-csharp.
                      //  Wait for semaphore to be released so that next task can start
                      static async Task<long> AwaitSemaphoreAsync(SemaphoreSlim semaphore)
                      {
                        Stopwatch stopwatch = Stopwatch.StartNew();
                        await semaphore.WaitAsync();
                        stopwatch.Stop();
                        return stopwatch.ElapsedTicks;
                      }

              p.mb-4
                | I created a mock async processing method that simulates work by delaying for a random amount of time. I also added telemetry data so that I could track the task ID, task count, semaphore count, and wait time. I used the
                code Task.Delay
                |  method to simulate work, but in a real-world application, this would be replaced with actual work.

              .card.shadow-sm.mb-4
                .card-header.bg-success.text-white
                  h5.mb-0
                    i.bi.bi-play-circle.me-2
                    | Mock Processing Task
                .card-body
                  pre.language-csharp.mb-0
                    code.language-csharp.
                      // Mock Async Task to simulate work
                      static async Task ProcessAsync(int taskId, int taskCount, long waitTicks, SemaphoreSlim semaphore)
                      {
                        try
                        {
                          await Task.Delay(TimeSpan.FromMilliseconds(new Random().Next(1, 500)));
                          Console.WriteLine($"Task:{taskId:D3} T:{taskCount} S:{semaphore.CurrentCount} W:{waitTicks}");
                        }
                        finally
                        {
                          semaphore.Release();
                        }
                      }

              p.mb-4 Finally, I created a function to generate the next task ID. This is how I controlled the number of tasks that were created.

              .card.shadow-sm.mb-4
                .card-header.bg-info.text-white
                  h5.mb-0
                    i.bi.bi-arrow-right-circle.me-2
                    | Task ID Generator
                .card-body
                  pre.language-csharp.mb-0
                    code.language-csharp.
                      // Get Next Task ID
                      static int? GetNextTaskId(int? taskId)
                      {
                        if (taskId < 1000) return taskId + 1;
                        else return null;
                      }

            section.mb-5
              h2.h3.mb-4
                i.bi.bi-arrow-repeat.me-2.text-primary
                | Iterating and Learning

              p.mb-4 As I dove into the code, I realized that understanding concurrent processing goes beyond just knowing how to create threads or tasks. I needed to comprehend the concept of synchronization and how to manage the number of concurrently executing tasks. The code I had started with was a great foundation, but it required iteration and refinement to achieve my goals.

              p.mb-4
                | The heart of the application was the use of the
                strong SemaphoreSlim
                |  class, which acted as a gatekeeper to control the number of tasks running concurrently. This was a crucial lesson in managing shared resources and preventing resource exhaustion.

            section.mb-5
              h2.h3.mb-4
                i.bi.bi-eye.me-2.text-primary
                | Experimenting and Observing

              p.mb-4 With each iteration of the code, I ran the application and observed its behavior. The output of the program provided valuable insights into how tasks were being managed, the time each task spent waiting for a semaphore, and the overall concurrency control.

              .card.shadow-sm.mb-4
                .card-header.bg-dark.text-white
                  h5.mb-0
                    i.bi.bi-terminal.me-2
                    | Sample Output
                .card-body
                  pre.language-json.mb-0
                    code.language-json.
                      ...
                      Task:061 T:61 S:2 W:2
                      Task:070 T:70 S:0 W:4
                      Task:037 T:37 S:0 W:2
                      Task:018 T:18 S:3 W:2
                      Task:023 T:23 S:1 W:2
                      Task:026 T:26 S:2 W:3
                      ...

              p.mb-4 The output highlighted the dynamic nature of concurrent processing, where tasks were processed and released in a controlled manner, ensuring that the maximum concurrency was maintained while avoiding resource contention.

            section.mb-5
              h2.h3.mb-4
                i.bi.bi-trophy.me-2.text-success
                | Celebrating Success

              p.mb-4 After several iterations, moments of frustration, and numerous debug sessions, I finally achieved my desired result. The application was now a well-functioning demonstration of concurrent processing, showcasing my newfound understanding of synchronization and resource management.

              p.mb-4 The journey was not just about the code; it was about the learning process itself. Developing this console application was a great learning tool that allowed me to grasp the intricacies of concurrent processing hands-on. It transformed abstract concepts into tangible knowledge.

            section.mb-5
              h2.h3.mb-4
                i.bi.bi-check-circle.me-2.text-success
                | Conclusion

              .card.bg-light.border-0
                .card-body
                  p.mb-3 The world of concurrent processing is complex and fascinating. Through the development of this C# console application, I gained valuable insights into managing multiple tasks simultaneously while avoiding common pitfalls. The iterative process of refining the code helped me internalize the concepts and apply them effectively.

                  p.mb-3 I encourage fellow developers to try learning through practical coding. It's one thing to read about a topic, but a whole different experience to see it in action and work through challenges firsthand.

                  p.mb-0
                    strong Happy coding and exploring the world of concurrency!

            section.mb-5
              .alert.alert-info.border-0.shadow-sm
                .row.align-items-center
                  .col-md-2.text-center
                    i.bi.bi-arrow-right-circle.display-4.text-primary
                  .col-md-10
                    h4.alert-heading.mb-3
                      i.bi.bi-lightbulb.me-2
                      | Ready for the Next Level?
                    p.mb-3
                      | Now that you've explored the fundamentals of concurrent processing with SemaphoreSlim,
                      | you're ready to tackle more advanced scenarios. Learn how to manage concurrent lists of tasks
                      | with different return types, robust error handling, and comprehensive telemetry.
                    p.mb-0
                      a.btn.btn-primary.btn-lg(href='/task-list-processor.html')
                        i.bi.bi-list-task.me-2
                        | Explore TaskListProcessor: Advanced Concurrent Operations
                        i.bi.bi-arrow-right.ms-2

            section.mb-5#SemaphoreSlimClass
              .card.shadow-sm
                .card-header.bg-primary.text-white
                  h3.card-title.mb-0
                    i.bi.bi-shield-check.me-2
                    | The SemaphoreSlim Class
                  .text-end
                    a.text-white.text-decoration-none(href='#top')
                      i.bi.bi-arrow-up.me-1
                      | Back to Top

                .card-body
                  p.mb-3
                    | The
                    strong SemaphoreSlim
                    |  class in .NET presents a robust solution for fine-tuning resource utilization. This lightweight semaphore is designed for scenarios where wait times are expected to be short, making it ideal for controlling the number of tasks executing in parallel within a single process.

                  p.mb-3
                    | The
                    strong SemaphoreSlim
                    |  class offers a simple, yet effective way to limit the number of threads that can access a specific resource or a pool of resources concurrently. This is particularly useful in scenarios where you need to throttle the usage of resources like network bandwidth or CPU time, preventing the system from being overwhelmed.

                  p.mb-3
                    | When integrating
                    strong SemaphoreSlim
                    |  into the Task List Processor, it allows precise control over the number of tasks running simultaneously. By setting the maximum concurrent tasks, we ensure efficient execution without overloading the system, especially crucial in high-load situations.

                  p.mb-4
                    | For more detailed information on
                    strong SemaphoreSlim
                    | , its usage, and examples, visit the
                    a.text-decoration-none(href='https://learn.microsoft.com/en-us/dotnet/api/system.threading.semaphoreslim', target='_blank', rel='noopener')
                      | Microsoft Documentation on SemaphoreSlim
                      i.bi.bi-box-arrow-up-ne.ms-1
                    | .

                  h4.mb-3
                    i.bi.bi-diagram-2.me-2.text-primary
                    | Semaphore vs SemaphoreSlim in .NET

                  p.mb-4 Choose Semaphore when you need inter-process synchronization or when dealing with named semaphores for system-wide visibility. Opt for SemaphoreSlim for more lightweight, intra-process synchronization where performance and efficiency are key considerations.

                  .row.g-4
                    .col-md-6
                      .card.h-100.border-warning
                        .card-header.bg-warning.text-dark
                          h5.mb-0
                            i.bi.bi-cpu.me-2
                            | Semaphore
                        .card-body
                          dl.mb-0
                            dt Nature
                            dd A wrapper around the Win32 semaphore object, suitable for local or system-wide named semaphores.

                            dt Usage
                            dd Ideal for thread synchronization across multiple processes or for inter-process communication.

                            dt Performance
                            dd Slower and more resource-intensive, relying on the system's kernel mode.

                            dt Functionality
                            dd Supports system-wide visibility and waiting on multiple semaphores.

                            dt Example
                            dd Synchronizing resource access across different applications on the same system.

                            dt.text-success Pros
                            dd Visibility across processes, suitable for complex synchronization.

                            dt.text-danger Cons
                            dd Heavier, slower, and suitable for long wait times. Involves kernel transitions.

                    .col-md-6
                      .card.h-100.border-success
                        .card-header.bg-success.text-white
                          h5.mb-0
                            i.bi.bi-lightning.me-2
                            | SemaphoreSlim
                        .card-body
                          dl.mb-0
                            dt Nature
                            dd Lightweight and fast, designed for use within a single process.

                            dt Usage
                            dd Best for short wait times and scenarios confined to a single process.

                            dt Performance
                            dd More efficient in memory and speed, using CLR synchronization primitives.

                            dt Functionality
                            dd Does not support named semaphores or system-wide visibility.

                            dt Example
                            dd Limiting concurrent calls to an external service in a web server application.

                            dt.text-success Pros
                            dd Faster, more memory-efficient, suited for fine-grained control within an app.

                            dt.text-danger Cons
                            dd Not suitable for inter-process communication, lacks system-wide visibility.

